// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Pred$GclAtom = require("./View/Pred.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function mark(type_, class_, range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: type_,
    class: class_
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */4] = Rebase.$$Array.concat(instance[/* decorations */4], /* array */[decoration]);
  return /* () */0;
}

function markLineSpecSoft(param, param$1) {
  return mark("highlight", "highlight-spec-soft", param, param$1);
}

function markLineSpecHard(param, param$1) {
  return mark("highlight", "highlight-spec-hard", param, param$1);
}

function highlightError(param, param$1) {
  return mark("highlight", "line-number-error", param, param$1);
}

function digHole(range, instance) {
  var start = range.start;
  var indent = " ".repeat(start.column);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Atom.Range(start, new Atom.Point(0, 1).translate(start));
  instance[/* editor */0].setTextInBufferRange(holeRange, holeText);
  var cursorPos = new Atom.Point(1, 0).translate(start);
  instance[/* editor */0].setCursorBufferPosition(cursorPos);
  return Async$GclAtom.resolve(/* () */0);
}

function fromCursorPosition(instance) {
  var cursor = instance[/* editor */0].getCursorBufferPosition();
  var smallestHole = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  Rebase.$$Array.forEach((function (spec) {
          var match = smallestHole[0];
          if (match !== undefined && !match[/* range */4].containsRange(spec[/* range */4])) {
            return 0;
          } else {
            smallestHole[0] = spec;
            return /* () */0;
          }
        }), Rebase.$$Array.filter((function (spec) {
              return spec[/* range */4].containsPoint(cursor);
            }), instance[/* specifications */5]));
  return smallestHole[0];
}

function getPayloadRange(spec) {
  var start = new Atom.Point(1, 0).translate(spec[/* range */4].start);
  var end_ = new Atom.Point(0, -2).translate(spec[/* range */4].end);
  return new Atom.Range(start, end_);
}

function getPayload(spec, instance) {
  var innerRange = getPayloadRange(spec);
  return instance[/* editor */0].getBuffer().getTextInRange(innerRange);
}

function resolve(i, instance) {
  var specs = Rebase.$$Array.filter((function (spec) {
          return spec[/* id */0] === i;
        }), instance[/* specifications */5]);
  return Rebase.$$Option.forEach((function (spec) {
                var startingRow = spec[/* range */4].start.row;
                var endingRow = spec[/* range */4].end.row;
                instance[/* editor */0].getBuffer().deleteRow(endingRow);
                instance[/* editor */0].getBuffer().deleteRow(startingRow);
                return /* () */0;
              }), Rebase.$$Array.get(specs, 0));
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve
};

function overlay(text, class_, tail, translation, range, instance) {
  var element = document.createElement("div");
  element.innerHTML = text;
  element.classList.add(class_);
  var top = (translation[0] - 1 | 0) * 1.5;
  element.setAttribute("style", "left: " + (String(translation[1]) + ("ex; top: " + (top.toString() + "em"))));
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "overlay",
    item: element,
    position: tail ? "tail" : "head"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */4] = Rebase.$$Array.concat(instance[/* decorations */4], /* array */[decoration]);
  return /* () */0;
}

function overlaySpec(text, range, instance) {
  return overlay(text, "overlay-spec-text", false, /* tuple */[
              0,
              1
            ], range, instance);
}

function overlayError(range, instance) {
  var length = instance[/* editor */0].getTextInBufferRange(range).length;
  var text = "&nbsp;".repeat(length);
  return overlay(text, "overlay-error", true, /* tuple */[
              0,
              0
            ], range, instance);
}

function markSpec(spec, instance) {
  var start = spec[/* range */4].start;
  var start$1 = new Atom.Range(start, start.translate(new Atom.Point(0, 2)));
  var end_ = spec[/* range */4].end;
  var end_$1 = new Atom.Range(end_.translate(new Atom.Point(0, -2)), end_);
  var match = spec[/* hardness */1];
  if (match) {
    markLineSpecSoft(start$1, instance);
  } else {
    markLineSpecHard(start$1, instance);
  }
  var trim = function (s) {
    if (Rebase.$$String.length(s) > 77) {
      return Rebase.$$String.sub(0, 73, s) + " ...";
    } else {
      return s;
    }
  };
  var pre = trim(Pred$GclAtom.toString(spec[/* pre */2]));
  var post = trim(Pred$GclAtom.toString(spec[/* post */3]));
  overlaySpec(pre, start$1, instance);
  overlaySpec(post, end_$1, instance);
  return markLineSpecSoft(end_$1, instance);
}

function markError(point, instance) {
  var range = new Atom.Range(point, new Atom.Point(point.row, point.column + 1 | 0));
  overlayError(range, instance);
  return mark("line-number", "line-number-error", range, instance);
}

function markError$prime(range, instance) {
  overlayError(range, instance);
  return mark("line-number", "line-number-error", range, instance);
}

function destroyAll(instance) {
  return Rebase.$$Array.forEach((function (prim) {
                prim.destroy();
                return /* () */0;
              }), instance[/* decorations */4]);
}

exports.mark = mark;
exports.markLineSpecSoft = markLineSpecSoft;
exports.markLineSpecHard = markLineSpecHard;
exports.highlightError = highlightError;
exports.digHole = digHole;
exports.Spec = Spec;
exports.overlay = overlay;
exports.overlaySpec = overlaySpec;
exports.overlayError = overlayError;
exports.markSpec = markSpec;
exports.markError = markError;
exports.markError$prime = markError$prime;
exports.destroyAll = destroyAll;
/* atom Not a pure module */
