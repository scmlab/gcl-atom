// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Decoder$GclAtom = require("../Decoder.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function decode(json) {
  return Decoder$GclAtom.sum((function (tag) {
                  switch (tag) {
                    case "Bol" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Bool */Caml_chrome_debugger.variant("Bool", 1, [x]);
                                                  }), Json_decode.bool, param);
                                    })]);
                    case "Num" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Num */Caml_chrome_debugger.variant("Num", 0, [x]);
                                                  }), Json_decode.$$int, param);
                                    })]);
                    default:
                      throw [
                            Json_decode.DecodeError,
                            "Unknown constructor: " + tag
                          ];
                  }
                }))(json);
}

function toString(param) {
  if (param.tag) {
    return Pervasives.string_of_bool(param[0]);
  } else {
    return String(param[0]);
  }
}

var Lit = {
  decode: decode,
  toString: toString
};

function toString$1(param) {
  switch (param) {
    case /* EQ */0 :
        return "=";
    case /* LTE */1 :
        return "<=";
    case /* GTE */2 :
        return ">=";
    case /* LT */3 :
        return "<";
    case /* GT */4 :
        return ">";
    case /* Implies */5 :
        return "→";
    case /* Conj */6 :
        return "⋀";
    case /* Disj */7 :
        return "⋁";
    case /* Neg */8 :
        return "¬";
    case /* Plus */9 :
        return "+";
    case /* Minus */10 :
        return "-";
    case /* Mul */11 :
        return "*";
    case /* Div */12 :
        return "/";
    
  }
}

function decode$1(param) {
  return Json_decode.map((function (tag) {
                switch (tag) {
                  case "Conj" :
                      return /* Conj */6;
                  case "Disj" :
                      return /* Disj */7;
                  case "Div" :
                      return /* Div */12;
                  case "EQ" :
                      return /* EQ */0;
                  case "GT" :
                      return /* GT */4;
                  case "GTE" :
                      return /* GTE */2;
                  case "Implies" :
                      return /* Implies */5;
                  case "LT" :
                      return /* LT */3;
                  case "LTE" :
                      return /* LTE */1;
                  case "Minus" :
                      return /* Minus */10;
                  case "Mul" :
                      return /* Mul */11;
                  case "Neg" :
                      return /* Neg */8;
                  case "Plus" :
                      return /* Plus */9;
                  default:
                    throw [
                          Json_decode.DecodeError,
                          "Unknown constructor: " + tag
                        ];
                }
              }), Json_decode.string, param);
}

var Op = {
  toString: toString$1,
  decode: decode$1
};

function decode$2(json) {
  return Decoder$GclAtom.sum((function (tag) {
                  switch (tag) {
                    case "App" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (param) {
                                                    return /* App */Caml_chrome_debugger.variant("App", 4, [
                                                              param[0],
                                                              param[1]
                                                            ]);
                                                  }), (function (param) {
                                                    return Json_decode.pair(decode$2, decode$2, param);
                                                  }), param);
                                    })]);
                    case "Const" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Const */Caml_chrome_debugger.variant("Const", 1, [x]);
                                                  }), Json_decode.string, param);
                                    })]);
                    case "Hole" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (param) {
                                                    return /* Hole */Caml_chrome_debugger.variant("Hole", 5, [
                                                              param[0],
                                                              param[1]
                                                            ]);
                                                  }), (function (param) {
                                                    return Json_decode.pair(Json_decode.$$int, (function (param) {
                                                                  return Json_decode.array(decodeSubst, param);
                                                                }), param);
                                                  }), param);
                                    })]);
                    case "Lit" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Lit */Caml_chrome_debugger.variant("Lit", 2, [x]);
                                                  }), decode, param);
                                    })]);
                    case "Op" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Op */Caml_chrome_debugger.variant("Op", 3, [x]);
                                                  }), decode$1, param);
                                    })]);
                    case "Var" :
                        return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                                      return Json_decode.map((function (x) {
                                                    return /* Var */Caml_chrome_debugger.variant("Var", 0, [x]);
                                                  }), Json_decode.string, param);
                                    })]);
                    default:
                      throw [
                            Json_decode.DecodeError,
                            "Unknown constructor: " + tag
                          ];
                  }
                }))(json);
}

function decodeSubst(json) {
  return Json_decode.dict(decode$2, json);
}

function compareInt(x, y) {
  var match = Caml_obj.caml_compare(x, y);
  if (match !== -1) {
    if (match !== 0) {
      return /* GreaterThan */1;
    } else {
      return /* Equal */0;
    }
  } else {
    return /* LessThan */2;
  }
}

function compare(x, y) {
  if (typeof x === "number") {
    return /* CantCompare */3;
  } else if (x.tag) {
    if (typeof y === "number" || !y.tag) {
      return /* CantCompare */3;
    } else {
      return compareInt(x[0], y[0]);
    }
  } else if (typeof y === "number" || y.tag) {
    return /* CantCompare */3;
  } else {
    return compareInt(x[0], y[0]);
  }
}

function succ(param) {
  if (typeof param === "number") {
    return /* Others */0;
  } else if (param.tag) {
    return /* Number */Caml_chrome_debugger.variant("Number", 1, [param[0] + 1 | 0]);
  } else {
    return /* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [param[0] + 1 | 0]);
  }
}

var Sort = {
  compareInt: compareInt,
  compare: compare,
  succ: succ
};

function classify(param) {
  switch (param) {
    case /* EQ */0 :
    case /* LTE */1 :
    case /* GTE */2 :
    case /* LT */3 :
    case /* GT */4 :
        return /* Infix */Caml_chrome_debugger.variant("Infix", 2, [/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [5])]);
    case /* Implies */5 :
        return /* InfixR */Caml_chrome_debugger.variant("InfixR", 1, [/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [1])]);
    case /* Conj */6 :
        return /* InfixL */Caml_chrome_debugger.variant("InfixL", 0, [/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [3])]);
    case /* Disj */7 :
        return /* InfixL */Caml_chrome_debugger.variant("InfixL", 0, [/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [2])]);
    case /* Neg */8 :
        return /* Prefix */Caml_chrome_debugger.variant("Prefix", 3, [/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [4])]);
    case /* Plus */9 :
    case /* Minus */10 :
        return /* InfixL */Caml_chrome_debugger.variant("InfixL", 0, [/* Number */Caml_chrome_debugger.variant("Number", 1, [2])]);
    case /* Mul */11 :
    case /* Div */12 :
        return /* InfixL */Caml_chrome_debugger.variant("InfixL", 0, [/* Number */Caml_chrome_debugger.variant("Number", 1, [1])]);
    
  }
}

function parensIf(p, s) {
  if (p) {
    return "(" + (s + ")");
  } else {
    return s;
  }
}

function greaterThan(x, y) {
  return compare(x, y) === /* GreaterThan */1;
}

function binary(n, op, p, q) {
  var match = classify(op);
  switch (match.tag | 0) {
    case /* InfixL */0 :
        var m = match[0];
        return parensIf(greaterThan(n, m), toString$2(m, p) + (" " + (toString$1(op) + (" " + toString$2(succ(m), q)))));
    case /* InfixR */1 :
        var m$1 = match[0];
        return parensIf(greaterThan(n, m$1), toString$2(succ(m$1), p) + (" " + (toString$1(op) + (" " + toString$2(m$1, q)))));
    case /* Infix */2 :
        var m$2 = match[0];
        return parensIf(greaterThan(n, m$2), toString$2(succ(m$2), p) + (" " + (toString$1(op) + (" " + toString$2(succ(m$2), q)))));
    case /* Prefix */3 :
        return toString$1(op) + (" " + (toString$2(n, p) + toString$2(n, q)));
    case /* Postfix */4 :
        return toString$2(n, p) + (toString$2(n, q) + (" " + toString$1(op)));
    
  }
}

function toString$2(n, param) {
  switch (param.tag | 0) {
    case /* Var */0 :
    case /* Const */1 :
        return param[0];
    case /* Lit */2 :
        return toString(param[0]);
    case /* Op */3 :
        return toString$1(param[0]);
    case /* App */4 :
        var x = param[0];
        switch (x.tag | 0) {
          case /* Op */3 :
              if (x[0] === 8) {
                return parensIf(greaterThan(n, /* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [4])), "¬ " + toString$2(/* Predicate */Caml_chrome_debugger.variant("Predicate", 0, [4]), param[1]));
              }
              break;
          case /* App */4 :
              var match = x[0];
              if (match.tag === /* Op */3) {
                return binary(n, match[0], x[1], param[1]);
              }
              break;
          default:
            
        }
        return toString$2(/* Others */0, x) + (" " + toString$2(/* Others */0, param[1]));
    case /* Hole */5 :
        return "[" + (String(param[0]) + "]");
    
  }
}

var Precedence = {
  Sort: Sort,
  classify: classify,
  parensIf: parensIf,
  greaterThan: greaterThan,
  binary: binary,
  toString: toString$2
};

function toString$3(param) {
  return toString$2(/* Others */0, param);
}

exports.Lit = Lit;
exports.Op = Op;
exports.decode = decode$2;
exports.decodeSubst = decodeSubst;
exports.Precedence = Precedence;
exports.toString = toString$3;
/* Decoder-GclAtom Not a pure module */
