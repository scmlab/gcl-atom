// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Base$GclAtom = require("../GCL/Base.bs.js");
var Syntax$GclAtom = require("../GCL/Syntax.bs.js");

function fromCursorPosition(state) {
  var cursor = state.editor.getCursorBufferPosition();
  var smallestHole = {
    contents: undefined
  };
  Rebase.$$Array.forEach((function (spec) {
          var match = smallestHole.contents;
          if (match !== undefined && !Base$GclAtom.Loc.toRange(match.loc).containsRange(Base$GclAtom.Loc.toRange(spec.loc))) {
            return 0;
          } else {
            smallestHole.contents = spec;
            return /* () */0;
          }
        }), Rebase.$$Array.filter((function (spec) {
              return Base$GclAtom.Loc.toRange(spec.loc).containsPoint(cursor);
            }), state.specifications));
  return smallestHole.contents;
}

function getPayloadRange(spec, state) {
  var startingRow = Base$GclAtom.Loc.toRange(spec.loc).start.row + 1 | 0;
  var endingRow = Base$GclAtom.Loc.toRange(spec.loc).end.row - 1 | 0;
  var start = state.editor.getBuffer().rangeForRow(startingRow, true).start;
  var end_ = state.editor.getBuffer().rangeForRow(endingRow, true).end;
  return new Atom.Range(start, end_);
}

function getPayload(spec, state) {
  var innerRange = getPayloadRange(spec, state);
  return state.editor.getBuffer().getTextInRange(innerRange);
}

function resolve(i, state) {
  var specs = Rebase.$$Array.filter((function (spec) {
          return spec.id === i;
        }), state.specifications);
  Rebase.$$Option.forEach((function (spec) {
          var payload = getPayload(spec, state);
          console.log("!!!! [ payload ]", payload);
          var start = Base$GclAtom.Loc.toRange(spec.loc).start;
          state.editor.getBuffer().delete(Base$GclAtom.Loc.toRange(spec.loc));
          state.editor.getBuffer().insert(start, payload.trim());
          return /* () */0;
        }), Rebase.$$Array.get(specs, 0));
  return $$Promise.resolved(/* () */0);
}

function toLoc(site, specifications) {
  if (site.tag) {
    var i = site[1];
    var loc = site[0];
    var specs = Rebase.$$Array.filter((function (spec) {
            return spec.id === i;
          }), specifications);
    return Rebase.$$Option.mapOr((function (spec) {
                  return Base$GclAtom.Loc.translateBy(1, 0, 1, 0, Base$GclAtom.Loc.translate(loc, spec.loc));
                }), loc, Rebase.$$Array.get(specs, 0));
  } else {
    return site[0];
  }
}

function toRange(site, specifications) {
  return Base$GclAtom.Loc.toRange(toLoc(site, specifications));
}

var Site = {
  toLoc: toLoc,
  toRange: toRange
};

function digHole(site, state) {
  var range = toRange(site, state.specifications);
  var start = range.start;
  var indent = " ".repeat(start.column);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Atom.Range(start, new Atom.Point(0, 1).translate(start));
  state.editor.setTextInBufferRange(holeRange, holeText);
  var cursorPos = new Atom.Point(1, 0).translate(start);
  state.editor.setCursorBufferPosition(cursorPos);
  return $$Promise.resolved(/* () */0);
}

function insert(lineNo, expr, state) {
  var assertion = "{ " + (Syntax$GclAtom.Expr.toString(expr) + " }\n");
  var point = new Atom.Point(lineNo - 1 | 0, 0);
  state.editor.setCursorScreenPosition(point);
  state.editor.insertText(assertion);
  return /* () */0;
}

exports.fromCursorPosition = fromCursorPosition;
exports.getPayloadRange = getPayloadRange;
exports.getPayload = getPayload;
exports.resolve = resolve;
exports.Site = Site;
exports.digHole = digHole;
exports.insert = insert;
/* atom Not a pure module */
