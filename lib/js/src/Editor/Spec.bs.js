// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Base2$GclAtom = require("../GCL/Base2.bs.js");
var GCL$Guacamole = require("guacamole/lib/js/src/GCL.bs.js");

function fromCursorPosition(state) {
  var cursor = state.editor.getCursorBufferPosition();
  var smallestHole = {
    contents: undefined
  };
  Belt_Array.forEach(Belt_Array.keep(state.specifications, (function (spec) {
              return Base2$GclAtom.Loc.toRange(spec.loc).containsPoint(cursor);
            })), (function (spec) {
          var match = smallestHole.contents;
          if (match !== undefined && !Base2$GclAtom.Loc.toRange(match.loc).containsRange(Base2$GclAtom.Loc.toRange(spec.loc))) {
            return 0;
          } else {
            smallestHole.contents = spec;
            return /* () */0;
          }
        }));
  return smallestHole.contents;
}

function getPayloadRange(spec, state) {
  var startingRow = Base2$GclAtom.Loc.toRange(spec.loc).start.row + 1 | 0;
  var endingRow = Base2$GclAtom.Loc.toRange(spec.loc).end.row - 1 | 0;
  var start = state.editor.getBuffer().rangeForRow(startingRow, true).start;
  var end_ = state.editor.getBuffer().rangeForRow(endingRow, true).end;
  return new Atom.Range(start, end_);
}

function getPayload(spec, state) {
  var innerRange = getPayloadRange(spec, state);
  return state.editor.getBuffer().getTextInRange(innerRange);
}

function resolve(i, state) {
  var specs = Belt_Array.keep(state.specifications, (function (spec) {
          return spec.id === i;
        }));
  Belt_Option.forEach(Belt_Array.get(specs, 0), (function (spec) {
          var payload = getPayload(spec, state);
          console.log("!!!! [ payload ]", payload);
          var start = Base2$GclAtom.Loc.toRange(spec.loc).start;
          state.editor.getBuffer().delete(Base2$GclAtom.Loc.toRange(spec.loc));
          state.editor.getBuffer().insert(start, payload.trim());
          return /* () */0;
        }));
  return $$Promise.resolved(/* () */0);
}

function toLoc(site, specifications) {
  if (site.tag) {
    var i = site[1];
    var loc = site[0];
    var specs = Belt_Array.keep(specifications, (function (spec) {
            return spec.id === i;
          }));
    return Belt_Option.mapWithDefault(Belt_Array.get(specs, 0), loc, (function (spec) {
                  return GCL$Guacamole.Loc.translateBy(1, 0, 1, 0, GCL$Guacamole.Loc.translate(loc, spec.loc));
                }));
  } else {
    return site[0];
  }
}

function toRange(site, specifications) {
  return Base2$GclAtom.Loc.toRange(toLoc(site, specifications));
}

var Site = {
  toLoc: toLoc,
  toRange: toRange
};

function digHole(site, state) {
  var range = toRange(site, state.specifications);
  var start = range.start;
  var indent = " ".repeat(start.column);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Atom.Range(start, new Atom.Point(0, 1).translate(start));
  state.editor.setTextInBufferRange(holeRange, holeText);
  var cursorPos = new Atom.Point(1, 0).translate(start);
  state.editor.setCursorBufferPosition(cursorPos);
  return $$Promise.resolved(/* () */0);
}

function insert(lineNo, expr, state) {
  var assertion = "{ " + (Curry._1(GCL$Guacamole.Syntax.Expr.toString, expr) + " }\n");
  var point = new Atom.Point(lineNo - 1 | 0, 0);
  state.editor.setCursorScreenPosition(point);
  state.editor.insertText(assertion);
  return /* () */0;
}

exports.fromCursorPosition = fromCursorPosition;
exports.getPayloadRange = getPayloadRange;
exports.getPayload = getPayload;
exports.resolve = resolve;
exports.Site = Site;
exports.digHole = digHole;
exports.insert = insert;
/* atom Not a pure module */
