// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Base$GclAtom = require("../GCL/Base.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function fromCursorPosition(instance) {
  var cursor = instance[/* editor */0].getCursorBufferPosition();
  var smallestHole = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  Rebase.$$Array.forEach((function (spec) {
          var match = smallestHole[0];
          if (match !== undefined && !Base$GclAtom.Loc.toRange(match[/* loc */3]).containsRange(Base$GclAtom.Loc.toRange(spec[/* loc */3]))) {
            return 0;
          } else {
            smallestHole[0] = spec;
            return /* () */0;
          }
        }), Rebase.$$Array.filter((function (spec) {
              return Base$GclAtom.Loc.toRange(spec[/* loc */3]).containsPoint(cursor);
            }), instance[/* specifications */5]));
  return smallestHole[0];
}

function getPayloadRange(spec, instance) {
  var startingRow = Base$GclAtom.Loc.toRange(spec[/* loc */3]).start.row + 1 | 0;
  var endingRow = Base$GclAtom.Loc.toRange(spec[/* loc */3]).end.row - 1 | 0;
  var start = instance[/* editor */0].getBuffer().rangeForRow(startingRow, true).start;
  var end_ = instance[/* editor */0].getBuffer().rangeForRow(endingRow, true).end;
  return new Atom.Range(start, end_);
}

function getPayload(spec, instance) {
  var innerRange = getPayloadRange(spec, instance);
  return instance[/* editor */0].getBuffer().getTextInRange(innerRange);
}

function resolve(i, instance) {
  var specs = Rebase.$$Array.filter((function (spec) {
          return spec[/* id */0] === i;
        }), instance[/* specifications */5]);
  Rebase.$$Option.forEach((function (spec) {
          var payload = getPayload(spec, instance);
          console.log("!!!! [ payload ]", payload);
          var start = Base$GclAtom.Loc.toRange(spec[/* loc */3]).start;
          instance[/* editor */0].getBuffer().delete(Base$GclAtom.Loc.toRange(spec[/* loc */3]));
          instance[/* editor */0].getBuffer().insert(start, payload.trim());
          return /* () */0;
        }), Rebase.$$Array.get(specs, 0));
  return $$Promise.resolved(/* () */0);
}

function toLoc(site, specifications) {
  if (site.tag) {
    var i = site[1];
    var loc = site[0];
    var specs = Rebase.$$Array.filter((function (spec) {
            return spec[/* id */0] === i;
          }), specifications);
    return Rebase.$$Option.mapOr((function (spec) {
                  return Base$GclAtom.Loc.translateBy(1, 0, 1, 0, Base$GclAtom.Loc.translate(loc, spec[/* loc */3]));
                }), loc, Rebase.$$Array.get(specs, 0));
  } else {
    return site[0];
  }
}

function toRange(site, specifications) {
  return Base$GclAtom.Loc.toRange(toLoc(site, specifications));
}

var Site = {
  toLoc: toLoc,
  toRange: toRange
};

function digHole(site, instance) {
  var range = toRange(site, instance[/* specifications */5]);
  var start = range.start;
  var indent = " ".repeat(start.column);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Atom.Range(start, new Atom.Point(0, 1).translate(start));
  instance[/* editor */0].setTextInBufferRange(holeRange, holeText);
  var cursorPos = new Atom.Point(1, 0).translate(start);
  instance[/* editor */0].setCursorBufferPosition(cursorPos);
  return $$Promise.resolved(/* () */0);
}

exports.fromCursorPosition = fromCursorPosition;
exports.getPayloadRange = getPayloadRange;
exports.getPayload = getPayload;
exports.resolve = resolve;
exports.Site = Site;
exports.digHole = digHole;
/* atom Not a pure module */
