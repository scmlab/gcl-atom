// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function pos(json) {
  return /* record */Caml_chrome_debugger.record([
            "filepath",
            "offset",
            "line",
            "column"
          ], [
            Json_decode.field("filepath", Json_decode.string, json),
            Json_decode.field("offset", Json_decode.$$int, json),
            Json_decode.field("line", Json_decode.$$int, json),
            Json_decode.field("column", Json_decode.$$int, json)
          ]);
}

function loc(param) {
  return Json_decode.andThen((function (param) {
                if (param === "Loc") {
                  return (function (param) {
                      return Json_decode.field("contents", (function (json) {
                                    return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
                                              Json_decode.field("start", pos, json),
                                              Json_decode.field("end", pos, json)
                                            ]);
                                  }), param);
                    });
                } else {
                  return (function (param) {
                      return /* NoLoc */0;
                    });
                }
              }), (function (param) {
                return Json_decode.field("tag", Json_decode.string, param);
              }), param);
}

function point(param) {
  return Json_decode.map((function (x) {
                return new Atom.Point(x[/* line */2] - 1 | 0, x[/* column */3]);
              }), pos, param);
}

function range(param) {
  return Json_decode.map((function (param) {
                if (param) {
                  var y = param[1];
                  var x = param[0];
                  return new Atom.Range(new Atom.Point(x[/* line */2] - 1 | 0, x[/* column */3] - 1 | 0), new Atom.Point(y[/* line */2] - 1 | 0, y[/* column */3] - 1 | 0));
                } else {
                  return new Atom.Range(new Atom.Point(0, 0), new Atom.Point(0, 0));
                }
              }), loc, param);
}

function ok(param) {
  return /* OK */0;
}

function parseErrorPair(param) {
  return Json_decode.pair(point, Json_decode.string, param);
}

function parseError(param) {
  return Json_decode.map((function (a) {
                return /* ParseError */Caml_chrome_debugger.variant("ParseError", 0, [a]);
              }), (function (param) {
                return Json_decode.array(parseErrorPair, param);
              }), param);
}

function syntaxError(param) {
  return Json_decode.andThen((function (tag) {
                switch (tag) {
                  case "ExcessBound" :
                      return (function (param) {
                          return Json_decode.field("contents", (function (json) {
                                        return /* ExcessBound */Caml_chrome_debugger.variant("ExcessBound", 2, [range(json)]);
                                      }), param);
                        });
                  case "MissingAssertion" :
                      return (function (param) {
                          return Json_decode.field("contents", (function (json) {
                                        return /* MissingAssertion */Caml_chrome_debugger.variant("MissingAssertion", 1, [range(json)]);
                                      }), param);
                        });
                  case "MissingBound" :
                      return (function (param) {
                          return Json_decode.field("contents", (function (json) {
                                        return /* MissingBound */Caml_chrome_debugger.variant("MissingBound", 0, [range(json)]);
                                      }), param);
                        });
                  default:
                    throw [
                          Json_decode.DecodeError,
                          "Unknown constructor: " + tag
                        ];
                }
              }), (function (param) {
                return Json_decode.field("tag", Json_decode.string, param);
              }), param);
}

function response(raw) {
  return Json_decode.andThen((function (param) {
                switch (param) {
                  case "OK" :
                      return ok;
                  case "ParseError" :
                      return (function (param) {
                          return Json_decode.field("contents", parseError, param);
                        });
                  case "SyntaxError" :
                      return (function (param) {
                          return Json_decode.field("contents", (function (json) {
                                        return /* SyntaxError */Caml_chrome_debugger.variant("SyntaxError", 1, [syntaxError(json)]);
                                      }), param);
                        });
                  default:
                    return (function (param) {
                        return /* UnknownResponse */Caml_chrome_debugger.variant("UnknownResponse", 2, [raw]);
                      });
                }
              }), (function (param) {
                return Json_decode.field("tag", Json_decode.string, param);
              }), raw);
}

var Decode = {
  pos: pos,
  loc: loc,
  point: point,
  range: range,
  ok: ok,
  parseErrorPair: parseErrorPair,
  parseError: parseError,
  syntaxError: syntaxError,
  response: response
};

function parse(data) {
  return Rebase.$$Option.map(response, Json.parse(data));
}

var test = Json.parse;

exports.Decode = Decode;
exports.parse = parse;
exports.test = test;
/* atom Not a pure module */
