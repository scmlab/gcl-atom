// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var View$GclAtom = require("./View.bs.js");
var Decoration$GclAtom = require("./Decoration.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(prim) {
  return new Atom.Disposable(prim);
}

function dispose(prim) {
  prim.dispose();
  
}

var Disposable = {
  make: make,
  dispose: dispose
};

function make$1(prim, prim$1) {
  return new Atom.Point(prim, prim$1);
}

function line(prim) {
  return prim.row;
}

function column(prim) {
  return prim.column;
}

function translate(p, x, y) {
  return p.translate(new Atom.Point(x, y));
}

function fromPos(param) {
  return new Atom.Point(param[1] - 1 | 0, param[2] - 1 | 0);
}

function toPos(point, filepath) {
  return /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
            filepath,
            point.row + 1 | 0,
            point.column + 1 | 0
          ]);
}

function make$2(prim, prim$1) {
  return new Atom.Range(prim, prim$1);
}

function start(prim) {
  return prim.start;
}

function end_(prim) {
  return prim.end;
}

function fromLoc(param) {
  if (!param) {
    return new Atom.Range(new Atom.Point(0, 0), new Atom.Point(0, 0));
  }
  var match = param[1];
  return new Atom.Range(fromPos(param[0]), new Atom.Point(match[1] - 1 | 0, match[2]));
}

function toLoc(range, filepath) {
  var start = range.start;
  var end_ = range.end;
  return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
            /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                filepath,
                start.row + 1 | 0,
                start.column + 1 | 0
              ]),
            /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                filepath,
                end_.row + 1 | 0,
                end_.column
              ])
          ]);
}

function contains(self, point) {
  return self.containsPoint(point);
}

function containsRange(self, others) {
  return self.containsRange(others);
}

var $$Range = {
  make: make$2,
  start: start,
  end_: end_,
  fromLoc: fromLoc,
  toLoc: toLoc,
  contains: contains,
  containsRange: containsRange
};

function getExtensionPath(param) {
  return Belt_Option.getWithDefault(atom.packages.resolvePackagePath("gcl-atom"), "");
}

function getFileName(editor) {
  return editor.getPath();
}

function save(editor) {
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(editor.save())), (function (param) {
                if (param.tag) {
                  return false;
                } else {
                  return true;
                }
              }));
}

function addToSubscriptions(disposable, subscriptions) {
  subscriptions.add(disposable);
  
}

function onDidCloseEditor(callback) {
  return atom.workspace.observeTextEditors((function (editor) {
                var subscriptions = new Atom.CompositeDisposable();
                subscriptions.add(editor.onDidDestroy((function (param) {
                            Belt_Option.forEach(editor.getPath(), callback);
                            subscriptions.dispose();
                            
                          })));
                
              }));
}

function onDidChangeFileName(callback) {
  return atom.workspace.observeTextEditors((function (editor) {
                var subscriptions = new Atom.CompositeDisposable();
                var previous = {
                  contents: editor.getPath()
                };
                subscriptions.add(editor.onDidChangePath((function (param) {
                            var next = editor.getPath();
                            if (Caml_obj.caml_notequal(next, previous.contents)) {
                              Curry._2(callback, previous.contents, next);
                              previous.contents = next;
                              return ;
                            }
                            
                          })));
                
              }));
}

function onDidChangeActivation(callback) {
  var previous = {
    contents: atom.workspace.getActiveTextEditor()
  };
  return atom.workspace.onDidChangeActiveTextEditor((function (next) {
                var previousFileName = Belt_Option.flatMap(previous.contents, (function (prim) {
                        return prim.getPath();
                      }));
                var nextFileName = Belt_Option.flatMap(next, (function (prim) {
                        return prim.getPath();
                      }));
                if (Caml_obj.caml_notequal(previousFileName, nextFileName)) {
                  Curry._2(callback, previousFileName, nextFileName);
                  previous.contents = next;
                  return ;
                }
                
              }));
}

function registerCommand(name, callback) {
  var eventTargetEditor = function ($$event) {
    var targetSubElement = $$event.target;
    var targetedEditors = Belt_Array.keep(atom.workspace.getTextEditors(), (function (x) {
            return atom.views.getView(x).contains(targetSubElement);
          }));
    return Belt_Array.get(targetedEditors, 0);
  };
  return atom.commands.add("atom-text-editor", "gcl-atom:" + name, (function ($$event) {
                return Belt_Option.forEach(eventTargetEditor($$event), callback);
              }));
}

function setGCLPath(value) {
  atom.config.set("gcl-atom.path", value);
  return $$Promise.resolved(undefined);
}

function getGCLPath(param) {
  return atom.config.get("gcl-atom.path");
}

function getCursorPosition(editor) {
  return editor.getCursorBufferPosition();
}

function rangeForLine(editor, line) {
  return editor.getBuffer().rangeForRow(line, true);
}

function getText(editor, range) {
  return editor.getBuffer().getTextInRange(range);
}

function selectText(editor, range) {
  editor.setSelectedScreenRange(range);
  
}

function insertText(editor, point, text) {
  editor.getBuffer().insert(point, text);
  return $$Promise.resolved(true);
}

function deleteText(editor, range) {
  editor.getBuffer().delete(range);
  return $$Promise.resolved(true);
}

var Impl_Point = {
  line: line,
  column: column,
  make: make$1,
  translate: translate,
  fromPos: fromPos,
  toPos: toPos
};

var Impl_Config = {
  getGCLPath: getGCLPath,
  setGCLPath: setGCLPath
};

var Impl_View = {
  make: View$GclAtom.make,
  destroy: View$GclAtom.destroy,
  show: View$GclAtom.show,
  hide: View$GclAtom.hide,
  send: View$GclAtom.send,
  recv: View$GclAtom.recv
};

var Impl = {
  Disposable: Disposable,
  Point: Impl_Point,
  $$Range: $$Range,
  editorType: /* Atom */0,
  getExtensionPath: getExtensionPath,
  getFileName: getFileName,
  save: save,
  onDidChangeFileName: onDidChangeFileName,
  onDidChangeActivation: onDidChangeActivation,
  onDidCloseEditor: onDidCloseEditor,
  registerCommand: registerCommand,
  addToSubscriptions: addToSubscriptions,
  Config: Impl_Config,
  View: Impl_View,
  Decoration: Decoration$GclAtom,
  getCursorPosition: getCursorPosition,
  rangeForLine: rangeForLine,
  getText: getText,
  selectText: selectText,
  insertText: insertText,
  deleteText: deleteText
};

exports.Impl = Impl;
/* atom Not a pure module */
