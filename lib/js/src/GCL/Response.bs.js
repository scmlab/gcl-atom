// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_list = require("bs-platform/lib/js/js_list.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Body$GclAtom = require("../View/Body.bs.js");
var Expr$GclAtom = require("../View/Expr.bs.js");
var Type$GclAtom = require("../View/Type.bs.js");
var Async$GclAtom = require("../Util/Async.bs.js");
var Decoder$GclAtom = require("./Decoder.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Specification$GclAtom = require("./Specification.bs.js");

var decode = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "Global" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (json) {
                            return /* Global */Caml_chrome_debugger.variant("Global", 0, [Decoder$GclAtom.range(json)]);
                          })]);
          case "Local" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* Local */Caml_chrome_debugger.variant("Local", 1, [
                                                    param[0],
                                                    param[1]
                                                  ]);
                                        }), (function (param) {
                                          return Json_decode.pair(Decoder$GclAtom.range, Json_decode.$$int, param);
                                        }), param);
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

function toRange(site, instance) {
  if (site.tag) {
    var i = site[1];
    var range = site[0];
    var specs = Rebase.$$Array.filter((function (spec) {
            return spec[/* id */0] === i;
          }), instance[/* specifications */5]);
    return Rebase.$$Option.mapOr((function (spec) {
                  return range.translate(spec[/* range */4].start, spec[/* range */4].start).translate(new Atom.Point(1, 0), new Atom.Point(1, 0));
                }), range, Rebase.$$Array.get(specs, 0));
  } else {
    return site[0];
  }
}

function toString(site) {
  var rangeToString = function (range) {
    return String(range.start.row) + (":" + (String(range.start.column) + ("-" + (String(range.end.row) + (":" + String(range.end.column))))));
  };
  if (site.tag) {
    return "at " + (rangeToString(site[0]) + (" in #" + String(site[1])));
  } else {
    return "at " + rangeToString(site[0]);
  }
}

var Site = {
  decode: decode,
  toRange: toRange,
  toString: toString
};

function mark(type_, class_, range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: type_,
    class: class_
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */4] = Rebase.$$Array.concat(instance[/* decorations */4], /* array */[decoration]);
  return /* () */0;
}

function markLineSpecSoft(param, param$1) {
  return mark("highlight", "highlight-spec-soft", param, param$1);
}

function markLineSpecHard(param, param$1) {
  return mark("highlight", "highlight-spec-hard", param, param$1);
}

function overlay(text, class_, tail, translation, range, instance) {
  var element = document.createElement("div");
  element.innerHTML = text;
  element.classList.add(class_);
  var top = (translation[0] - 1 | 0) * 1.5;
  element.setAttribute("style", "left: " + (String(translation[1]) + ("ex; top: " + (top.toString() + "em"))));
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "overlay",
    item: element,
    position: tail ? "tail" : "head"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */4] = Rebase.$$Array.concat(instance[/* decorations */4], /* array */[decoration]);
  return /* () */0;
}

function overlaySpec(text, range, instance) {
  return overlay(text, "overlay-spec-text", false, /* tuple */[
              0,
              1
            ], range, instance);
}

function overlayError(range, instance) {
  var length = instance[/* editor */0].getTextInBufferRange(range).length;
  var text = "&nbsp;".repeat(length);
  return overlay(text, "overlay-error", true, /* tuple */[
              0,
              0
            ], range, instance);
}

function markSpec(spec, instance) {
  var start = spec[/* range */4].start;
  var start$1 = new Atom.Range(start, start.translate(new Atom.Point(0, 2)));
  var end_ = spec[/* range */4].end;
  var end_$1 = new Atom.Range(end_.translate(new Atom.Point(0, -2)), end_);
  var match = spec[/* hardness */1];
  if (match) {
    markLineSpecSoft(start$1, instance);
  } else {
    markLineSpecHard(start$1, instance);
  }
  var trim = function (s) {
    if (Rebase.$$String.length(s) > 77) {
      return Rebase.$$String.sub(0, 73, s) + " ...";
    } else {
      return s;
    }
  };
  var pre = trim(Expr$GclAtom.toString(spec[/* pre */2]));
  var post = trim(Expr$GclAtom.toString(spec[/* post */3]));
  overlaySpec(pre, start$1, instance);
  overlaySpec(post, end_$1, instance);
  return markLineSpecSoft(end_$1, instance);
}

function markSite(site, instance) {
  var range = toRange(site, instance);
  overlayError(range, instance);
  mark("line-number", "line-number-error", range, instance);
  return Async$GclAtom.resolve(/* [] */0);
}

function destroyAll(instance) {
  return Rebase.$$Array.forEach((function (prim) {
                prim.destroy();
                return /* () */0;
              }), instance[/* decorations */4]);
}

var Decoration = {
  mark: mark,
  markLineSpecSoft: markLineSpecSoft,
  markLineSpecHard: markLineSpecHard,
  overlay: overlay,
  overlaySpec: overlaySpec,
  overlayError: overlayError,
  markSpec: markSpec,
  markSite: markSite,
  destroyAll: destroyAll
};

function fromCursorPosition(instance) {
  var cursor = instance[/* editor */0].getCursorBufferPosition();
  var smallestHole = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  Rebase.$$Array.forEach((function (spec) {
          var match = smallestHole[0];
          if (match !== undefined && !match[/* range */4].containsRange(spec[/* range */4])) {
            return 0;
          } else {
            smallestHole[0] = spec;
            return /* () */0;
          }
        }), Rebase.$$Array.filter((function (spec) {
              return spec[/* range */4].containsPoint(cursor);
            }), instance[/* specifications */5]));
  return smallestHole[0];
}

function getPayloadRange(spec, instance) {
  var start = new Atom.Point(1, 0).translate(spec[/* range */4].start);
  var end_ = instance[/* editor */0].getBuffer().rangeForRow(spec[/* range */4].end.row - 1 | 0, true).end;
  return new Atom.Range(start, end_);
}

function getPayload(spec, instance) {
  var innerRange = getPayloadRange(spec, instance);
  return instance[/* editor */0].getBuffer().getTextInRange(innerRange);
}

function resolve(i, instance) {
  var specs = Rebase.$$Array.filter((function (spec) {
          return spec[/* id */0] === i;
        }), instance[/* specifications */5]);
  Rebase.$$Option.forEach((function (spec) {
          var payload = getPayload(spec, instance);
          var start = spec[/* range */4].start;
          instance[/* editor */0].getBuffer().delete(spec[/* range */4]);
          instance[/* editor */0].getBuffer().insert(start, payload.trim());
          return /* () */0;
        }), Rebase.$$Array.get(specs, 0));
  return Async$GclAtom.resolve(/* () */0);
}

function digHole(site, instance) {
  var range = toRange(site, instance);
  var start = range.start;
  var indent = " ".repeat(start.column);
  var holeText = "{!\n" + (indent + ("\n" + (indent + "!}")));
  var holeRange = new Atom.Range(start, new Atom.Point(0, 1).translate(start));
  instance[/* editor */0].setTextInBufferRange(holeRange, holeText);
  var cursorPos = new Atom.Point(1, 0).translate(start);
  instance[/* editor */0].setCursorBufferPosition(cursorPos);
  return Async$GclAtom.resolve(/* () */0);
}

var Spec = {
  fromCursorPosition: fromCursorPosition,
  getPayloadRange: getPayloadRange,
  getPayload: getPayload,
  resolve: resolve,
  digHole: digHole
};

var decode$1 = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "NotFunction" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* NotFunction */Caml_chrome_debugger.variant("NotFunction", 3, [param[0]]);
                                        }), (function (param) {
                                          return Json_decode.pair(Type$GclAtom.decode, Decoder$GclAtom.range, param);
                                        }), param);
                          })]);
          case "NotInScope" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* NotInScope */Caml_chrome_debugger.variant("NotInScope", 0, [param[0]]);
                                        }), (function (param) {
                                          return Json_decode.pair(Json_decode.string, Decoder$GclAtom.range, param);
                                        }), param);
                          })]);
          case "RecursiveType" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* RecursiveType */Caml_chrome_debugger.variant("RecursiveType", 2, [
                                                    param[0],
                                                    param[1]
                                                  ]);
                                        }), (function (param) {
                                          return Json_decode.tuple3(Json_decode.$$int, Type$GclAtom.decode, Decoder$GclAtom.range, param);
                                        }), param);
                          })]);
          case "UnifyFailed" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* UnifyFailed */Caml_chrome_debugger.variant("UnifyFailed", 1, [
                                                    param[0],
                                                    param[1]
                                                  ]);
                                        }), (function (param) {
                                          return Json_decode.tuple3(Type$GclAtom.decode, Type$GclAtom.decode, Decoder$GclAtom.range, param);
                                        }), param);
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

var $$TypeError = {
  decode: decode$1
};

var decode$2 = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "DigHole" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return /* DigHole */4;
                          })]);
          case "ExcessBound" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return /* ExcessBound */2;
                          })]);
          case "MissingAssertion" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return /* MissingAssertion */1;
                          })]);
          case "MissingBound" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return /* MissingBound */0;
                          })]);
          case "MissingPostcondition" :
              return /* TagOnly */Caml_chrome_debugger.variant("TagOnly", 1, [(function (param) {
                            return /* MissingPostcondition */3;
                          })]);
          case "Panic" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (json) {
                            return /* Panic */Caml_chrome_debugger.simpleVariant("Panic", [Json_decode.string(json)]);
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

var ConvertError = {
  decode: decode$2
};

var decodeKind = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "ConvertError" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (json) {
                            return /* ConvertError */Caml_chrome_debugger.variant("ConvertError", 1, [Curry._1(decode$2, json)]);
                          })]);
          case "LexicalError" :
              return /* TagOnly */Caml_chrome_debugger.variant("TagOnly", 1, [(function (param) {
                            return /* LexicalError */0;
                          })]);
          case "SyntacticError" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* SyntacticError */Caml_chrome_debugger.variant("SyntacticError", 0, [param[1]]);
                                        }), (function (param) {
                                          return Json_decode.pair(Decoder$GclAtom.range, Json_decode.string, param);
                                        }), param);
                          })]);
          case "TypeError" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (json) {
                            return /* TypeError */Caml_chrome_debugger.variant("TypeError", 2, [Curry._1(decode$1, json)]);
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

function decode$3(param) {
  return Json_decode.map((function (param) {
                return /* Error */Caml_chrome_debugger.simpleVariant("Error", [
                          param[0],
                          param[1]
                        ]);
              }), (function (param) {
                return Json_decode.pair(decode, decodeKind, param);
              }), param);
}

function handle(error) {
  var kind = error[1];
  var site = error[0];
  if (typeof kind === "number") {
    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
              /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                      return markSite(site, param);
                    })]),
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* Display */Caml_chrome_debugger.variant("Display", 4, [
                      /* Error */Caml_chrome_debugger.variant("Error", 1, ["Lexical Error"]),
                      /* Plain */Caml_chrome_debugger.variant("Plain", 1, [toString(site)])
                    ]),
                  /* [] */0
                ])
            ]);
  } else {
    switch (kind.tag | 0) {
      case /* SyntacticError */0 :
          return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                            return markSite(site, param);
                          })]),
                    /* :: */Caml_chrome_debugger.simpleVariant("::", [
                        /* Display */Caml_chrome_debugger.variant("Display", 4, [
                            /* Error */Caml_chrome_debugger.variant("Error", 1, ["Parse Error"]),
                            /* Plain */Caml_chrome_debugger.variant("Plain", 1, [kind[0]])
                          ]),
                        /* [] */0
                      ])
                  ]);
      case /* ConvertError */1 :
          var match = kind[0];
          if (typeof match === "number") {
            switch (match) {
              case /* MissingBound */0 :
                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                    return markSite(site, param);
                                  })]),
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                    /* Error */Caml_chrome_debugger.variant("Error", 1, ["Bound Missing"]),
                                    /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\""])
                                  ]),
                                /* [] */0
                              ])
                          ]);
              case /* MissingAssertion */1 :
                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                    return markSite(site, param);
                                  })]),
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                    /* Error */Caml_chrome_debugger.variant("Error", 1, ["Assertion Missing"]),
                                    /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Assertion before the DO construct is missing"])
                                  ]),
                                /* [] */0
                              ])
                          ]);
              case /* ExcessBound */2 :
                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                    return markSite(site, param);
                                  })]),
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                    /* Error */Caml_chrome_debugger.variant("Error", 1, ["Excess Bound"]),
                                    /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Unnecessary bound annotation at this assertion"])
                                  ]),
                                /* [] */0
                              ])
                          ]);
              case /* MissingPostcondition */3 :
                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                /* Error */Caml_chrome_debugger.variant("Error", 1, ["Postcondition Missing"]),
                                /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The last statement of the program should be an assertion"])
                              ]),
                            /* [] */0
                          ]);
              case /* DigHole */4 :
                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (instance) {
                                    console.log("dig!");
                                    return Async$GclAtom.thenOk((function (param) {
                                                    var match = instance[/* history */6];
                                                    if (match !== undefined && match.tag) {
                                                      console.log("!!");
                                                      return Async$GclAtom.resolve(/* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                                    /* DispatchLocal */Caml_chrome_debugger.variant("DispatchLocal", 2, [/* Save */1]),
                                                                    /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                                        /* DispatchLocal */Caml_chrome_debugger.variant("DispatchLocal", 2, [/* Refine */2]),
                                                                        /* [] */0
                                                                      ])
                                                                  ]));
                                                    } else {
                                                      return Async$GclAtom.resolve(/* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                                    /* DispatchLocal */Caml_chrome_debugger.variant("DispatchLocal", 2, [/* Save */1]),
                                                                    /* [] */0
                                                                  ]));
                                                    }
                                                  }))(digHole(site, instance));
                                  })]),
                            /* [] */0
                          ]);
              
            }
          } else {
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Display */Caml_chrome_debugger.variant("Display", 4, [
                          /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic"]),
                          /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["This should not have happened, please report this issue\n" + match[0]])
                        ]),
                      /* [] */0
                    ]);
          }
      case /* TypeError */2 :
          var match$1 = kind[0];
          switch (match$1.tag | 0) {
            case /* NotInScope */0 :
                return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                  return markSite(site, param);
                                })]),
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                  /* Error */Caml_chrome_debugger.variant("Error", 1, ["Type Error"]),
                                  /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The definition " + (match$1[0] + " is not in scope")])
                                ]),
                              /* [] */0
                            ])
                        ]);
            case /* UnifyFailed */1 :
                return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                  return markSite(site, param);
                                })]),
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                  /* Error */Caml_chrome_debugger.variant("Error", 1, ["Type Error"]),
                                  /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Cannot unify: " + (Type$GclAtom.toString(match$1[0]) + ("\nwith        : " + Type$GclAtom.toString(match$1[1])))])
                                ]),
                              /* [] */0
                            ])
                        ]);
            case /* RecursiveType */2 :
                return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                  return markSite(site, param);
                                })]),
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                  /* Error */Caml_chrome_debugger.variant("Error", 1, ["Type Error"]),
                                  /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Recursive type variable: " + (Type$GclAtom.toString(/* Var */Caml_chrome_debugger.variant("Var", 3, [match$1[0]])) + ("\nin type             : " + Type$GclAtom.toString(match$1[1])))])
                                ]),
                              /* [] */0
                            ])
                        ]);
            case /* NotFunction */3 :
                return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (param) {
                                  return markSite(site, param);
                                })]),
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* Display */Caml_chrome_debugger.variant("Display", 4, [
                                  /* Error */Caml_chrome_debugger.variant("Error", 1, ["Type Error"]),
                                  /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The type " + (Type$GclAtom.toString(match$1[0]) + " is not a function type")])
                                ]),
                              /* [] */0
                            ])
                        ]);
            
          }
      
    }
  }
}

var $$Error = {
  $$TypeError: $$TypeError,
  ConvertError: ConvertError,
  decodeKind: decodeKind,
  decode: decode$3,
  handle: handle
};

var decode$4 = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "Error" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (errors) {
                                          return /* Error */Caml_chrome_debugger.variant("Error", 0, [errors]);
                                        }), (function (param) {
                                          return Json_decode.array(decode$3, param);
                                        }), param);
                          })]);
          case "OK" :
              var partial_arg = Body$GclAtom.ProofObligation.decode;
              var partial_arg$1 = function (param) {
                return Json_decode.array(partial_arg, param);
              };
              var partial_arg$2 = function (param) {
                return Json_decode.pair(partial_arg$1, (function (param) {
                              return Json_decode.array(Specification$GclAtom.decode, param);
                            }), param);
              };
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (param) {
                                          return /* OK */Caml_chrome_debugger.variant("OK", 1, [
                                                    param[0],
                                                    param[1]
                                                  ]);
                                        }), partial_arg$2, param);
                          })]);
          case "Resolve" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (param) {
                            return Json_decode.map((function (i) {
                                          return /* Resolve */Caml_chrome_debugger.variant("Resolve", 2, [i]);
                                        }), Json_decode.$$int, param);
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

function handle$1(response) {
  switch (response.tag | 0) {
    case /* Error */0 :
        return Js_list.flatten(Rebase.List.fromArray(Rebase.$$Array.map(handle, response[0])));
    case /* OK */1 :
        var specifications = response[1];
        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (instance) {
                          Rebase.$$Array.forEach(Curry._2(Rebase.Fn.flip, markSpec, instance), specifications);
                          instance[/* specifications */5] = specifications;
                          return Async$GclAtom.resolve(/* [] */0);
                        })]),
                  /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Display */Caml_chrome_debugger.variant("Display", 4, [
                          /* Plain */Caml_chrome_debugger.variant("Plain", 0, ["Proof Obligations"]),
                          /* ProofObligations */Caml_chrome_debugger.variant("ProofObligations", 0, [response[0]])
                        ]),
                      /* [] */0
                    ])
                ]);
    case /* Resolve */2 :
        var i = response[0];
        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* WithInstance */Caml_chrome_debugger.variant("WithInstance", 0, [(function (instance) {
                          return Async$GclAtom.thenOk((function (param) {
                                          return Async$GclAtom.resolve(/* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                        /* DispatchLocal */Caml_chrome_debugger.variant("DispatchLocal", 2, [/* Save */1]),
                                                        /* [] */0
                                                      ]));
                                        }))(resolve(i, instance));
                        })]),
                  /* [] */0
                ]);
    case /* UnknownResponse */3 :
        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* Display */Caml_chrome_debugger.variant("Display", 4, [
                      /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic: unknown response from GCL"]),
                      /* Plain */Caml_chrome_debugger.variant("Plain", 1, [JSON.stringify(response[0])])
                    ]),
                  /* [] */0
                ]);
    
  }
}

exports.Site = Site;
exports.Decoration = Decoration;
exports.Spec = Spec;
exports.$$Error = $$Error;
exports.decode = decode$4;
exports.handle = handle$1;
/* decode Not a pure module */
