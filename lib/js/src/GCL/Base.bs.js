// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Decoder$GclAtom = require("./Decoder.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toPoint(param) {
  return new Atom.Point(param[1] - 1 | 0, param[2] - 1 | 0);
}

function toString(param) {
  return String(param[1]) + (":" + String(param[2]));
}

function translate(by, param) {
  return /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
            param[0],
            param[1] + by[1] | 0,
            param[2] + by[2] | 0
          ]);
}

function translateBy(y, x, param) {
  return /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
            param[0],
            param[1] + y | 0,
            param[2] + x | 0
          ]);
}

function decode(json) {
  return /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
            Json_decode.field("filepath", Json_decode.string, json),
            Json_decode.field("line", Json_decode.$$int, json),
            Json_decode.field("column", Json_decode.$$int, json)
          ]);
}

var Pos = {
  toPoint: toPoint,
  toString: toString,
  translate: translate,
  translateBy: translateBy,
  decode: decode
};

function toRange(param) {
  if (param) {
    var match = param[1];
    return new Atom.Range(toPoint(param[0]), new Atom.Point(match[1] - 1 | 0, match[2]));
  } else {
    return new Atom.Range(new Atom.Point(0, 0), new Atom.Point(0, 0));
  }
}

function toString$1(param) {
  if (param) {
    return toString(param[0]) + ("-" + toString(param[1]));
  } else {
    return "NoLoc";
  }
}

function translate$1(by, param) {
  if (param) {
    var y = param[1];
    var x = param[0];
    if (by) {
      return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
                translate(x, by[0]),
                translate(y, by[1])
              ]);
    } else {
      return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
                x,
                y
              ]);
    }
  } else {
    return by;
  }
}

function translateBy$1(startY, startX, endY, endX, param) {
  if (param) {
    return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
              translateBy(startY, startX, param[0]),
              translateBy(endY, endX, param[1])
            ]);
  } else {
    return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
              /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                  "",
                  startY,
                  startX
                ]),
              /* Pos */Caml_chrome_debugger.simpleVariant("Pos", [
                  "",
                  endY,
                  endX
                ])
            ]);
  }
}

var decode$1 = Decoder$GclAtom.sum((function (tag) {
        switch (tag) {
          case "Loc" :
              return /* Contents */Caml_chrome_debugger.variant("Contents", 0, [(function (json) {
                            return /* Loc */Caml_chrome_debugger.simpleVariant("Loc", [
                                      Json_decode.field("start", decode, json),
                                      Json_decode.field("end", decode, json)
                                    ]);
                          })]);
          case "NoLoc" :
              return /* TagOnly */Caml_chrome_debugger.variant("TagOnly", 1, [(function (param) {
                            return /* NoLoc */0;
                          })]);
          default:
            throw [
                  Json_decode.DecodeError,
                  "Unknown constructor: " + tag
                ];
        }
      }));

var Loc = {
  toRange: toRange,
  toString: toString$1,
  translate: translate$1,
  translateBy: translateBy$1,
  decode: decode$1
};

exports.Pos = Pos;
exports.Loc = Loc;
/* decode Not a pure module */
