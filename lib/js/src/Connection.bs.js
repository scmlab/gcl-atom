// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Util$GclAtom = require("./Util.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Event$GclAtom = require("./Util/Event.bs.js");
var Child_process = require("child_process");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toString(param) {
  switch (param.tag | 0) {
    case /* AutoSearchError */0 :
        var match = param[0];
        switch (match.tag | 0) {
          case /* ProcessHanging */0 :
              var name = match[0];
              if (name === "gcl") {
                return /* tuple */[
                        "Process not responding",
                        "Please restart the process"
                      ];
              } else {
                return /* tuple */[
                        "Process not responding when looking for \"" + (name + "\""),
                        "Please restart the process"
                      ];
              }
          case /* NotSupported */1 :
              return /* tuple */[
                      "Auto search failed",
                      "currently auto path searching is not supported on " + (String(match[0]) + "")
                    ];
          case /* NotFound */2 :
              var name$1 = match[0];
              if (name$1 === "gcl") {
                return /* tuple */[
                        "Auto search failed",
                        match[1]
                      ];
              } else {
                return /* tuple */[
                        "Auto search failed when looking for \"" + (name$1 + "\""),
                        match[1]
                      ];
              }
          
        }
    case /* ValidationError */1 :
        var match$1 = param[1];
        if (typeof match$1 === "number") {
          return /* tuple */[
                  "Process hanging",
                  "The program has not been responding for more than 1 sec"
                ];
        } else {
          switch (match$1.tag | 0) {
            case /* PathMalformed */0 :
                return /* tuple */[
                        "Path malformed",
                        match$1[0]
                      ];
            case /* NotFound */1 :
                return /* tuple */[
                        "GCL not found",
                        Util$GclAtom.JsError.toString(match$1[0])
                      ];
            case /* ShellError */2 :
                return /* tuple */[
                        "Error from the shell",
                        Util$GclAtom.JsError.toString(match$1[0])
                      ];
            case /* ProcessError */3 :
                return /* tuple */[
                        "Error from the stderr",
                        match$1[0]
                      ];
            case /* IsNotGCL */4 :
                return /* tuple */[
                        "This is not GCL",
                        match$1[0]
                      ];
            
          }
        }
    case /* ConnectionError */2 :
        var match$2 = param[0];
        if (typeof match$2 === "number") {
          return /* tuple */[
                  "Disconnected",
                  "Connection disconnected by ourselves"
                ];
        } else if (match$2.tag) {
          return /* tuple */[
                  "Socket closed by GCL",
                  "code: " + (String(match$2[0]) + ("\nsignal: " + (String(match$2[1]) + "\n")))
                ];
        } else {
          return /* tuple */[
                  "Socket error",
                  Util$GclAtom.JsError.toString(match$2[0])
                ];
        }
    
  }
}

var $$Error = {
  toString: toString
};

function disconnect(self) {
  self[/* process */1].kill("SIGTERM");
  self[/* connected */2] = false;
  return /* () */0;
}

function connect(path) {
  var $$process = Child_process.spawn(path, /* array */[], {
        shell: true
      });
  var connection = /* record */Caml_chrome_debugger.record([
      "path",
      "process",
      "connected"
    ], [
      path,
      $$process,
      true
    ]);
  return Async$GclAtom.mapError((function (e) {
                  return /* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [e]);
                }))(($$process.on("error", (function (exn) {
                          disconnect(connection);
                          console.log(/* ShellError */Caml_chrome_debugger.variant("ShellError", 0, [exn]));
                          return /* () */0;
                        })).on("close", (function (code, signal) {
                        disconnect(connection);
                        console.log(/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 1, [
                                code,
                                signal
                              ]));
                        return /* () */0;
                      })).on("message", (function (prim) {
                      console.log(prim);
                      return /* () */0;
                    })), Async$GclAtom.resolve(connection)));
}

function autoSearch(name) {
  return Async$GclAtom.mapError((function (e) {
                  return /* AutoSearchError */Caml_chrome_debugger.variant("AutoSearchError", 0, [e]);
                }))(Async$GclAtom.make((function (resolve, reject) {
                    var hangTimeout = setTimeout((function (param) {
                            return Curry._1(reject, /* ProcessHanging */Caml_chrome_debugger.variant("ProcessHanging", 0, [name]));
                          }), 1000);
                    var os = Os.type();
                    var commandName;
                    switch (os) {
                      case "Darwin" :
                      case "Linux" :
                          commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["which"]);
                          break;
                      case "Windows_NT" :
                          commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["where.exe"]);
                          break;
                      default:
                        commandName = /* Error */Caml_chrome_debugger.variant("Error", 1, [os]);
                    }
                    if (commandName.tag) {
                      return Curry._1(reject, /* NotSupported */Caml_chrome_debugger.variant("NotSupported", 1, [commandName[0]]));
                    } else {
                      Child_process.exec(commandName[0] + (" " + name), (function (error, stdout, stderr) {
                              clearTimeout(hangTimeout);
                              if (!(error == null)) {
                                Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                        name,
                                        Rebase.$$Option.getOr("", error.message)
                                      ]));
                              }
                              var stderr$prime = stderr.toString();
                              if (!Rebase.$$String.isEmpty(stderr$prime)) {
                                Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                        name,
                                        stderr$prime
                                      ]));
                              }
                              var stdout$prime = stdout.toString();
                              if (Rebase.$$String.isEmpty(stdout$prime)) {
                                return Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                              name,
                                              ""
                                            ]));
                              } else {
                                return Curry._1(resolve, stdout$prime);
                              }
                            }));
                      return /* () */0;
                    }
                  })));
}

function send(request, self) {
  var $$event = Event$GclAtom.make(/* () */0);
  var onData = function (chunk) {
    var rawText = chunk.toString();
    return Event$GclAtom.emitOk(rawText, $$event);
  };
  self[/* process */1].stdout.once("data", onData);
  var promise = Event$GclAtom.once($$event);
  var payload = Buffer.from(request + "\n");
  self[/* process */1].stdin.write(payload);
  return promise;
}

exports.$$Error = $$Error;
exports.disconnect = disconnect;
exports.connect = connect;
exports.autoSearch = autoSearch;
exports.send = send;
/* os Not a pure module */
