// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Events = require("events");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Nd__Events = require("bs-nd/lib/js/src/Nd__Events.bs.js");
var Ok$GclAtom = require("./Util/Ok.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$GclAtom = require("./Util.bs.js");
var Child_process = require("child_process");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toString(param) {
  switch (param.tag | 0) {
    case /* AutoSearchError */0 :
        var match = param[0];
        switch (match.tag | 0) {
          case /* ProcessHanging */0 :
              var name = match[0];
              if (name === "gcl") {
                return /* tuple */[
                        "Process not responding",
                        "Please restart the process"
                      ];
              } else {
                return /* tuple */[
                        "Process not responding when looking for \"" + (name + "\""),
                        "Please restart the process"
                      ];
              }
          case /* NotSupported */1 :
              return /* tuple */[
                      "Auto search failed",
                      "currently auto path searching is not supported on " + (String(match[0]) + "")
                    ];
          case /* NotFound */2 :
              var name$1 = match[0];
              if (name$1 === "gcl") {
                return /* tuple */[
                        "Auto search failed",
                        match[1]
                      ];
              } else {
                return /* tuple */[
                        "Auto search failed when looking for \"" + (name$1 + "\""),
                        match[1]
                      ];
              }
          
        }
    case /* ValidationError */1 :
        var match$1 = param[1];
        if (typeof match$1 === "number") {
          return /* tuple */[
                  "Process hanging",
                  "The program has not been responding for more than 1 sec"
                ];
        } else {
          switch (match$1.tag | 0) {
            case /* PathMalformed */0 :
                return /* tuple */[
                        "Path malformed",
                        match$1[0]
                      ];
            case /* NotFound */1 :
                return /* tuple */[
                        "GCL not found",
                        Util$GclAtom.JsError.toString(match$1[0])
                      ];
            case /* ShellError */2 :
                return /* tuple */[
                        "Error from the shell",
                        Util$GclAtom.JsError.toString(match$1[0])
                      ];
            case /* ProcessError */3 :
                return /* tuple */[
                        "Error from the stderr",
                        match$1[0]
                      ];
            case /* IsNotGCL */4 :
                return /* tuple */[
                        "This is not GCL",
                        match$1[0]
                      ];
            
          }
        }
    case /* ConnectionError */2 :
        var match$2 = param[0];
        if (typeof match$2 === "number") {
          if (match$2 === /* DisconnectedByUser */0) {
            return /* tuple */[
                    "Disconnected",
                    "Connection disconnected by ourselves"
                  ];
          } else {
            return /* tuple */[
                    "Connection not established yet",
                    "Please establish the connection first"
                  ];
          }
        } else {
          switch (match$2.tag | 0) {
            case /* ClosedByProcess */0 :
                return /* tuple */[
                        "Socket closed by GCL",
                        "exited with code: " + (String(match$2[0]) + ("\nsignal: " + (String(match$2[1]) + "\n")))
                      ];
            case /* ShellError */1 :
                return /* tuple */[
                        "Socket error",
                        Util$GclAtom.JsError.toString(match$2[0])
                      ];
            case /* ExitedByProcess */2 :
                return /* tuple */[
                        "GCL has crashed",
                        "exited with code: " + (String(match$2[0]) + ("\n  signal: " + (String(match$2[1]) + "\n  ")))
                      ];
            
          }
        }
    
  }
}

var $$Error = {
  toString: toString
};

function make(param) {
  var emitter = new Events.EventEmitter();
  return /* record */Caml_chrome_debugger.record([
            "emitter",
            "emit",
            "once",
            "on",
            "destroy"
          ], [
            emitter,
            (function (x) {
                emitter.emit("data", x);
                return /* () */0;
              }),
            (function (param) {
                var match = $$Promise.pending(/* () */0);
                emitter.once("data", match[1]);
                return match[0];
              }),
            (function (callback) {
                Nd__Events.on("data", callback, emitter);
                return /* () */0;
              }),
            (function (param) {
                emitter.removeAllListeners();
                return /* () */0;
              })
          ]);
}

var Emitter = {
  make: make
};

function disconnect(connection) {
  Curry._1(connection[/* emitter */2][/* destroy */4], /* () */0);
  Rebase.$$Option.forEach((function (param) {
          param.kill("SIGTERM");
          return /* () */0;
        }), connection[/* process */1]);
  connection[/* process */1] = undefined;
  return $$Promise.resolved(/* () */0);
}

function isConnected(connection) {
  return connection[/* process */1] !== undefined;
}

function make$1(param) {
  return /* record */Caml_chrome_debugger.record([
            "path",
            "process",
            "emitter"
          ], [
            undefined,
            undefined,
            make(/* () */0)
          ]);
}

function autoSearch(name) {
  var match = $$Promise.pending(/* () */0);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */Caml_chrome_debugger.variant("ProcessHanging", 0, [name])]));
        }), 1000);
  var os = Os.type();
  var commandName;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["which"]);
        break;
    case "Windows_NT" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["where.exe"]);
        break;
    default:
      commandName = /* Error */Caml_chrome_debugger.variant("Error", 1, [os]);
  }
  if (commandName.tag) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotSupported */Caml_chrome_debugger.variant("NotSupported", 1, [commandName[0]])]));
  } else {
    Child_process.exec(commandName[0] + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            if (!(error == null)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          Rebase.$$Option.getOr("", error.message)
                        ])]));
            }
            var stderr$prime = stderr.toString();
            if (!Rebase.$$String.isEmpty(stderr$prime)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          stderr$prime
                        ])]));
            }
            var stdout$prime = stdout.toString();
            if (Rebase.$$String.isEmpty(stdout$prime)) {
              return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                name,
                                ""
                              ])]));
            } else {
              return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [stdout$prime]));
            }
          }));
  }
  return $$Promise.mapError(match[0], (function (e) {
                return /* AutoSearchError */Caml_chrome_debugger.variant("AutoSearchError", 0, [e]);
              }));
}

function connect(connection) {
  return Ok$GclAtom.let_(autoSearch("gcl"), (function (path) {
                var $$process = Child_process.spawn(path, /* array */[], {
                      shell: true
                    });
                connection[/* path */0] = path;
                connection[/* process */1] = Caml_option.some($$process);
                var unfinishedMsg = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
                $$process.stdout.on("data", (function (chunk) {
                        var string = chunk.toString();
                        var match = unfinishedMsg[0];
                        var augmented = match !== undefined ? match + string : string;
                        var match$1 = Json.parse(augmented);
                        if (match$1 !== undefined) {
                          unfinishedMsg[0] = undefined;
                          Curry._1(connection[/* emitter */2][/* emit */1], /* Ok */Caml_chrome_debugger.variant("Ok", 0, [Caml_option.valFromOption(match$1)]));
                          return /* () */0;
                        } else {
                          unfinishedMsg[0] = augmented;
                          return /* () */0;
                        }
                      }));
                $$process.stdin.on("close", (function (param) {
                        disconnect(connection);
                        return /* () */0;
                      }));
                $$process.on("close", (function (code, signal) {
                              Curry._1(connection[/* emitter */2][/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                                              code,
                                              signal
                                            ])])]));
                              disconnect(connection);
                              return /* () */0;
                            })).on("disconnect", (function (param) {
                            Curry._1(connection[/* emitter */2][/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [/* DisconnectedByUser */0])]));
                            disconnect(connection);
                            return /* () */0;
                          })).on("error", (function (exn) {
                          Curry._1(connection[/* emitter */2][/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [/* ShellError */Caml_chrome_debugger.variant("ShellError", 1, [exn])])]));
                          disconnect(connection);
                          return /* () */0;
                        })).on("exit", (function (code, signal) {
                        Curry._1(connection[/* emitter */2][/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [/* ExitedByProcess */Caml_chrome_debugger.variant("ExitedByProcess", 2, [
                                        code,
                                        signal
                                      ])])]));
                        disconnect(connection);
                        return /* () */0;
                      }));
                return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
              }));
}

function send(request, connection) {
  var match = connection[/* process */1];
  if (match !== undefined) {
    var promise = Curry._1(connection[/* emitter */2][/* once */2], /* () */0);
    var payload = Buffer.from(request + "\n");
    Caml_option.valFromOption(match).stdin.write(payload);
    return promise;
  } else {
    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [/* NotEstablishedYet */1])]));
  }
}

exports.$$Error = $$Error;
exports.Emitter = Emitter;
exports.disconnect = disconnect;
exports.isConnected = isConnected;
exports.make = make$1;
exports.autoSearch = autoSearch;
exports.connect = connect;
exports.send = send;
/* os Not a pure module */
