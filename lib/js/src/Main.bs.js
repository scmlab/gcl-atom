// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var P$GclAtom = require("./Util/P.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Command$GclAtom = require("./Editor/Command.bs.js");
var Instance$GclAtom = require("./Instance.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Task__Command$GclAtom = require("./Task/Task__Command.bs.js");
var Task__Response$GclAtom = require("./Task/Task__Response.bs.js");

var activated = /* record */Caml_chrome_debugger.record(["contents"], [false]);

var instances = { };

function textEditorID(textEditor) {
  return String(textEditor.id);
}

function get(textEditor) {
  return Js_dict.get(instances, String(textEditor.id));
}

function getThen(f, textEditor) {
  return Rebase.$$Option.forEach(f, Js_dict.get(instances, String(textEditor.id)));
}

function add(textEditor) {
  var match = Js_dict.get(instances, String(textEditor.id));
  if (match !== undefined) {
    return /* () */0;
  } else {
    instances[String(textEditor.id)] = Instance$GclAtom.make(textEditor);
    return /* () */0;
  }
}

function delete_ (id){{delete instances[id]}};

function remove(textEditor) {
  var id = String(textEditor.id);
  var match = Js_dict.get(instances, id);
  if (match !== undefined) {
    Instance$GclAtom.destroy(match);
    delete_(id);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function destroyAll(param) {
  return Rebase.$$Array.forEach((function (param) {
                Instance$GclAtom.destroy(param[1]);
                delete_(param[0]);
                return /* () */0;
              }), Js_dict.entries(instances));
}

function contains(textEditor) {
  return Js_dict.get(instances, String(textEditor.id)) !== undefined;
}

function size(param) {
  return Rebase.$$Array.length(Object.keys(instances));
}

var Instances = {
  textEditorID: textEditorID,
  get: get,
  getThen: getThen,
  add: add,
  delete_: delete_,
  remove: remove,
  destroyAll: destroyAll,
  contains: contains,
  size: size
};

function isGCLFile(textEditor) {
  var filepath = Rebase.$$Option.getOr("untitled", textEditor.getPath());
  return (/\.gcl$/i).test(filepath);
}

var subscriptions = new Atom.CompositeDisposable();

function onEditorActivationChange(param) {
  var previous = /* record */Caml_chrome_debugger.record(["contents"], [atom.workspace.getActiveTextEditor()]);
  subscriptions.add(atom.workspace.onDidChangeActiveTextEditor((function (next) {
              var partial_arg = Instance$GclAtom.View.hide;
              Rebase.$$Option.forEach((function (param) {
                      return getThen(partial_arg, param);
                    }), previous[0]);
              if (next !== undefined) {
                var nextEditor = Caml_option.valFromOption(next);
                getThen(Instance$GclAtom.View.show, nextEditor);
                previous[0] = Caml_option.some(nextEditor);
                return /* () */0;
              } else {
                return /* () */0;
              }
            })));
  return /* () */0;
}

function eventTargetEditor($$event) {
  var targetSubElement = $$event.target;
  var targetedEditors = Rebase.$$Array.filter((function (x) {
          return atom.views.getView(x).contains(targetSubElement);
        }), atom.workspace.getTextEditors());
  return Rebase.$$Array.get(targetedEditors, 0);
}

function onTriggerCommand(param) {
  var runTasks = function (instance, tasks) {
    var runTask = function (task) {
      switch (task.tag | 0) {
        case /* WithInstance */0 :
            return $$Promise.flatMap(Curry._1(task[0], instance), (function (param) {
                          return runTasks(instance, param);
                        }));
        case /* SetSpecifications */1 :
            console.log("[ set specifications ]");
            instance[/* specifications */5] = task[0];
            return $$Promise.resolved(/* () */0);
        case /* AddDecorations */2 :
            console.log("[ add decorations ]");
            instance[/* decorations */4] = Rebase.$$Array.concat(Curry._2(task[0], instance[/* specifications */5], instance[/* editor */0]), instance[/* decorations */4]);
            return $$Promise.resolved(/* () */0);
        case /* DispatchRemote */3 :
            var command = task[0];
            console.log("[ dispatch remote ]", command);
            instance[/* history */6] = command;
            return runTasks(instance, Task__Command$GclAtom.Remote.dispatch(command));
        case /* DispatchLocal */4 :
            var command$1 = task[0];
            console.log("[ dispatch local ]", command$1);
            return runTasks(instance, Task__Command$GclAtom.Local.dispatch(command$1));
        case /* SendRequest */5 :
            console.log("[ send ]");
            return $$Promise.flatMap(Instance$GclAtom.Connection_.sendRequest(task[0], instance), (function (param) {
                          if (param.tag) {
                            var match = Instance$GclAtom.$$Error.toString(param[0]);
                            Instance$GclAtom.View.displayError(match[0], match[1], instance);
                            return $$Promise.resolved(/* () */0);
                          } else {
                            return runTasks(instance, Task__Response$GclAtom.handle(param[0]));
                          }
                        }));
        case /* Display */6 :
            Curry._1(instance[/* view */1][/* setHeader */1], task[0]);
            Curry._1(instance[/* view */1][/* setBody */2], task[1]);
            return $$Promise.resolved(/* () */0);
        
      }
    };
    var runEach = function (param) {
      if (param) {
        var xs = param[1];
        return P$GclAtom.let_(runTask(param[0]), (function (param) {
                      return P$GclAtom.let_(runEach(xs), (function (param) {
                                    return $$Promise.resolved(/* () */0);
                                  }));
                    }));
      } else {
        return $$Promise.resolved(/* () */0);
      }
    };
    return runEach(tasks);
  };
  return Rebase.$$Array.forEach((function (command) {
                subscriptions.add(atom.commands.add("atom-text-editor", "gcl-atom:" + command, (function ($$event) {
                            return Rebase.$$Option.forEach((function (instance) {
                                          runTasks(instance, Task__Command$GclAtom.Local.dispatch(Command$GclAtom.Local.parse(command)));
                                          return /* () */0;
                                        }), Rebase.$$Option.flatMap(get, eventTargetEditor($$event)));
                          })));
                return /* () */0;
              }), Command$GclAtom.Local.commandNames);
}

function onOpenEditor(param) {
  subscriptions.add(atom.workspace.observeTextEditors((function (textEditor) {
              var textEditorSubscriptions = new Atom.CompositeDisposable();
              if (isGCLFile(textEditor)) {
                add(textEditor);
              }
              textEditorSubscriptions.add(textEditor.onDidChangePath((function (param) {
                          if (!isGCLFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          if (isGCLFile(textEditor) && !contains(textEditor)) {
                            return add(textEditor);
                          } else {
                            return 0;
                          }
                        })));
              textEditorSubscriptions.add(textEditor.onDidDestroy((function (param) {
                          if (isGCLFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          textEditorSubscriptions.dispose();
                          return /* () */0;
                        })));
              return /* () */0;
            })));
  return /* () */0;
}

function setup(param) {
  onOpenEditor(/* () */0);
  onEditorActivationChange(/* () */0);
  return onTriggerCommand(/* () */0);
}

function activate(param) {
  if (!activated[0]) {
    activated[0] = true;
    setup(/* () */0);
  }
  return Promise.resolve(/* () */0);
}

function deactivate(param) {
  if (activated[0]) {
    activated[0] = false;
    destroyAll(/* () */0);
    subscriptions.dispose();
    return /* () */0;
  } else {
    return 0;
  }
}

exports.activated = activated;
exports.instances = instances;
exports.Instances = Instances;
exports.isGCLFile = isGCLFile;
exports.subscriptions = subscriptions;
exports.onEditorActivationChange = onEditorActivationChange;
exports.eventTargetEditor = eventTargetEditor;
exports.onTriggerCommand = onTriggerCommand;
exports.onOpenEditor = onOpenEditor;
exports.setup = setup;
exports.activate = activate;
exports.deactivate = deactivate;
/* subscriptions Not a pure module */
