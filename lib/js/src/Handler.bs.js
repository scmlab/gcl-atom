// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function markLineError(range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "line",
    class: "marker-error"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */3] = Rebase.$$Array.concat(instance[/* decorations */3], /* array */[decoration]);
  return /* () */0;
}

function markRangeError(range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "highlight",
    class: "marker-error"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */3] = Rebase.$$Array.concat(instance[/* decorations */3], /* array */[decoration]);
  return /* () */0;
}

function handle(instance, param) {
  if (typeof param === "number") {
    Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
    Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
    return Async$GclAtom.resolve(/* () */0);
  } else {
    switch (param.tag | 0) {
      case /* ParseError */0 :
          var match = Rebase.$$Array.get(param[0], 0);
          if (match !== undefined) {
            var match$1 = match;
            var pos = match$1[0];
            Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Parse Error"]));
            Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match$1[1]]));
            var range = new Atom.Range(pos, pos);
            markLineError(range, instance);
            return Async$GclAtom.resolve(/* () */0);
          } else {
            Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
            Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
            return Async$GclAtom.resolve(/* () */0);
          }
      case /* SyntaxError */1 :
          var match$2 = param[0];
          if (typeof match$2 === "number") {
            Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Postcondition Missing"]));
            Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The last statement of the program should be an assertion"]));
            return Async$GclAtom.resolve(/* () */0);
          } else {
            switch (match$2.tag | 0) {
              case /* MissingBound */0 :
                  Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Bound Missing"]));
                  Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\""]));
                  markRangeError(match$2[0], instance);
                  return Async$GclAtom.resolve(/* () */0);
              case /* MissingAssertion */1 :
                  Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Assertion Missing"]));
                  Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Assertion before the DO construct is missing"]));
                  markRangeError(match$2[0], instance);
                  return Async$GclAtom.resolve(/* () */0);
              case /* ExcessBound */2 :
                  Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Excess Bound"]));
                  Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Unnecessary bound annotation at this assertion"]));
                  markRangeError(match$2[0], instance);
                  return Async$GclAtom.resolve(/* () */0);
              case /* Panic */3 :
                  Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic"]));
                  Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["This should not have happened, please report this issue\n" + match$2[0]]));
                  return Async$GclAtom.resolve(/* () */0);
              
            }
          }
      case /* ProofObligations */2 :
          Curry._1(instance[/* view */1][/* setHeader */1], /* Plain */Caml_chrome_debugger.variant("Plain", 0, ["Proof Obligations"]));
          Curry._1(instance[/* view */1][/* setBody */2], /* ProofObligations */Caml_chrome_debugger.variant("ProofObligations", 0, [param[0]]));
          return Async$GclAtom.resolve(/* () */0);
      case /* UnknownResponse */3 :
          Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic: unknown response from GCL"]));
          Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [JSON.stringify(param[0])]));
          return Async$GclAtom.resolve(/* () */0);
      
    }
  }
}

exports.markLineError = markLineError;
exports.markRangeError = markRangeError;
exports.handle = handle;
/* atom Not a pure module */
