// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function markLineError(range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "line",
    class: "marker-error"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */3] = Rebase.$$Array.concat(instance[/* decorations */3], /* array */[decoration]);
  return /* () */0;
}

function markRangeError(range, instance) {
  var marker = instance[/* editor */0].markBufferRange(range);
  var option = {
    type: "highlight",
    class: "marker-error"
  };
  var decoration = instance[/* editor */0].decorateMarker(marker, option);
  instance[/* decorations */3] = Rebase.$$Array.concat(instance[/* decorations */3], /* array */[decoration]);
  return /* () */0;
}

function handle(instance, param) {
  if (typeof param === "number") {
    Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
    Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
    return /* () */0;
  } else {
    switch (param.tag | 0) {
      case /* ParseError */0 :
          var match = Rebase.$$Array.get(param[0], 0);
          if (match !== undefined) {
            var match$1 = match;
            var pos = match$1[0];
            Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Parse Error"]));
            Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.simpleVariant("Plain", [match$1[1]]));
            var range = new Atom.Range(pos, pos);
            return markLineError(range, instance);
          } else {
            Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
            Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
            return /* () */0;
          }
      case /* SyntaxError */1 :
          var match$2 = param[0];
          switch (match$2.tag | 0) {
            case /* MissingBound */0 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Bound Missing"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.simpleVariant("Plain", ["Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\""]));
                markRangeError(match$2[0], instance);
                return /* () */0;
            case /* MissingAssertion */1 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Assertion Missing"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.simpleVariant("Plain", ["Assertion before the DO construct is missing"]));
                markRangeError(match$2[0], instance);
                return /* () */0;
            case /* ExcessBound */2 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Excess Bound"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.simpleVariant("Plain", ["Unnecessary bound annotation at this assertion"]));
                markRangeError(match$2[0], instance);
                return /* () */0;
            
          }
      case /* UnknownResponse */2 :
          Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic: unknown response from GCL"]));
          Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.simpleVariant("Plain", [JSON.stringify(param[0])]));
          return /* () */0;
      
    }
  }
}

exports.markLineError = markLineError;
exports.markRangeError = markRangeError;
exports.handle = handle;
/* atom Not a pure module */
