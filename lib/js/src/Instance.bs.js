// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var View$GclAtom = require("./View.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Handler$GclAtom = require("./Handler.bs.js");
var Request$GclAtom = require("./Request.bs.js");
var Response$GclAtom = require("./Response.bs.js");
var Connection$GclAtom = require("./Connection.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(editor) {
  atom.views.getView(editor).classList.add("gcl");
  var view = View$GclAtom.make(editor);
  var connection = Connection$GclAtom.make(/* () */0);
  return /* record */Caml_chrome_debugger.record([
            "editor",
            "view",
            "toggle",
            "connection",
            "decorations",
            "specifications"
          ], [
            editor,
            view,
            false,
            connection,
            [],
            []
          ]);
}

function destroy(instance) {
  atom.views.getView(instance[/* editor */0]).classList.remove("gcl");
  Connection$GclAtom.disconnect(instance[/* connection */3]);
  Rebase.$$Array.forEach((function (prim) {
          prim.destroy();
          return /* () */0;
        }), instance[/* decorations */4]);
  return View$GclAtom.destroy(instance[/* editor */0]);
}

function showView(instance) {
  Curry._1(instance[/* view */1][/* setActivation */0], true);
  return /* () */0;
}

function hideView(instance) {
  Curry._1(instance[/* view */1][/* setActivation */0], false);
  return /* () */0;
}

function getConnection(instance) {
  if (Connection$GclAtom.isConnected(instance[/* connection */3])) {
    return Async$GclAtom.resolve(instance[/* connection */3]);
  } else {
    return Async$GclAtom.thenOk((function (param) {
                    return Async$GclAtom.resolve(instance[/* connection */3]);
                  }))(Async$GclAtom.thenError((function (error) {
                        var match = Connection$GclAtom.$$Error.toString(error);
                        Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                        Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                        return Async$GclAtom.resolve(/* () */0);
                      }))(Connection$GclAtom.connect(instance[/* connection */3])));
  }
}

function dispatch(request, instance) {
  switch (request) {
    case /* Toggle */0 :
        if (instance[/* toggle */2]) {
          instance[/* toggle */2] = false;
          hideView(instance);
          Rebase.$$Array.forEach((function (prim) {
                  prim.destroy();
                  return /* () */0;
                }), instance[/* decorations */4]);
          Connection$GclAtom.disconnect(instance[/* connection */3]);
          return Async$GclAtom.resolve(/* () */0);
        } else {
          instance[/* toggle */2] = true;
          showView(instance);
          if (Connection$GclAtom.isConnected(instance[/* connection */3])) {
            return Async$GclAtom.resolve(/* () */0);
          } else {
            return Async$GclAtom.thenOk((function (param) {
                            return dispatch(/* Save */1, instance);
                          }))(Async$GclAtom.thenError((function (error) {
                                var match = Connection$GclAtom.$$Error.toString(error);
                                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                                return Async$GclAtom.resolve(/* () */0);
                              }))(Connection$GclAtom.connect(instance[/* connection */3])));
          }
        }
    case /* Save */1 :
        Rebase.$$Array.forEach((function (prim) {
                prim.destroy();
                return /* () */0;
              }), instance[/* decorations */4]);
        return Async$GclAtom.thenOk((function (result) {
                        console.log("[ received json ]", result);
                        console.log("[ received value ]", Response$GclAtom.decode(result));
                        return handle(instance, Response$GclAtom.decode(result));
                      }))(Async$GclAtom.thenOk((function (param) {
                            var filepath = instance[/* editor */0].getPath();
                            if (filepath !== undefined) {
                              var partial_arg = Request$GclAtom.encode(/* Load */Caml_chrome_debugger.variant("Load", 0, [filepath]));
                              return Async$GclAtom.mapError((function (error) {
                                              var match = Connection$GclAtom.$$Error.toString(error);
                                              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                                              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                                              return /* () */0;
                                            }))(Async$GclAtom.thenOk((function (param) {
                                                  return Connection$GclAtom.send(partial_arg, param);
                                                }))(getConnection(instance)));
                            } else {
                              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read filepath "]));
                              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Please save the file first"]));
                              return Async$GclAtom.reject(/* () */0);
                            }
                          }))(Async$GclAtom.mapError((function (param) {
                                return /* () */0;
                              }))(Async$GclAtom.fromPromise(instance[/* editor */0].save()))));
    case /* Refine */2 :
        return Rebase.$$Option.mapOr((function (spec) {
                      var payload = Handler$GclAtom.Spec.getPayload(spec, instance);
                      var partial_arg = Request$GclAtom.encode(/* Refine */Caml_chrome_debugger.variant("Refine", 1, [
                              spec[/* id */0],
                              payload
                            ]));
                      return Async$GclAtom.thenOk((function (result) {
                                      console.log("[ received json ]", result);
                                      console.log("[ received value ]", Response$GclAtom.decode(result));
                                      return handle(instance, Response$GclAtom.decode(result));
                                    }))(Async$GclAtom.mapError((function (error) {
                                          var match = Connection$GclAtom.$$Error.toString(error);
                                          Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                                          Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                                          return /* () */0;
                                        }))(Async$GclAtom.thenOk((function (param) {
                                              return Connection$GclAtom.send(partial_arg, param);
                                            }))(getConnection(instance))));
                    }), Async$GclAtom.resolve(/* () */0), Handler$GclAtom.Spec.fromCursorPosition(instance));
    
  }
}

function handle(instance, param) {
  switch (param.tag | 0) {
    case /* Error */0 :
        var match = param[0];
        switch (match.tag | 0) {
          case /* LexicalError */0 :
              var point = match[0];
              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Lexical Error"]));
              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["at " + (String(point.row) + ("," + String(point.column)))]));
              Handler$GclAtom.markError(point, instance);
              return Async$GclAtom.resolve(/* () */0);
          case /* SyntacticError */1 :
              var match$1 = Rebase.$$Array.get(match[0], 0);
              if (match$1 !== undefined) {
                var match$2 = match$1;
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Parse Error"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match$2[/* message */1]]));
                Rebase.$$Array.forEach((function (range) {
                        return Handler$GclAtom.markError$prime(range, instance);
                      }), match$2[/* locations */0]);
                return Async$GclAtom.resolve(/* () */0);
              } else {
                Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
                Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
                return Async$GclAtom.resolve(/* () */0);
              }
          case /* TransformError */2 :
              var match$3 = match[0];
              if (typeof match$3 === "number") {
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Postcondition Missing"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The last statement of the program should be an assertion"]));
                return Async$GclAtom.resolve(/* () */0);
              } else {
                switch (match$3.tag | 0) {
                  case /* MissingBound */0 :
                      Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Bound Missing"]));
                      Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\""]));
                      Handler$GclAtom.highlightError(match$3[0], instance);
                      return Async$GclAtom.resolve(/* () */0);
                  case /* MissingAssertion */1 :
                      Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Assertion Missing"]));
                      Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Assertion before the DO construct is missing"]));
                      Handler$GclAtom.highlightError(match$3[0], instance);
                      return Async$GclAtom.resolve(/* () */0);
                  case /* ExcessBound */2 :
                      Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Excess Bound"]));
                      Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Unnecessary bound annotation at this assertion"]));
                      Handler$GclAtom.highlightError(match$3[0], instance);
                      return Async$GclAtom.resolve(/* () */0);
                  case /* DigHole */3 :
                      return Async$GclAtom.thenOk((function (param) {
                                      return dispatch(/* Save */1, instance);
                                    }))(Handler$GclAtom.digHole(match$3[0], instance));
                  case /* Panic */4 :
                      Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic"]));
                      Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["This should not have happened, please report this issue\n" + match$3[0]]));
                      return Async$GclAtom.resolve(/* () */0);
                  
                }
              }
          
        }
    case /* OK */1 :
        var specifications = param[1];
        Curry._1(instance[/* view */1][/* setHeader */1], /* Plain */Caml_chrome_debugger.variant("Plain", 0, ["Proof Obligations"]));
        Curry._1(instance[/* view */1][/* setBody */2], /* ProofObligations */Caml_chrome_debugger.variant("ProofObligations", 0, [param[0]]));
        Rebase.$$Array.forEach(Curry._2(Rebase.Fn.flip, Handler$GclAtom.markSpec, instance), specifications);
        instance[/* specifications */5] = specifications;
        return Async$GclAtom.resolve(/* () */0);
    case /* Resolve */2 :
        var i = param[0];
        console.log("[ resolving ] " + String(i));
        Handler$GclAtom.Spec.resolve(i, instance);
        return Async$GclAtom.resolve(/* () */0);
    case /* UnknownResponse */3 :
        Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic: unknown response from GCL"]));
        Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [JSON.stringify(param[0])]));
        return Async$GclAtom.resolve(/* () */0);
    
  }
}

var $$Event = 0;

exports.$$Event = $$Event;
exports.make = make;
exports.destroy = destroy;
exports.showView = showView;
exports.hideView = hideView;
exports.getConnection = getConnection;
exports.dispatch = dispatch;
exports.handle = handle;
/* View-GclAtom Not a pure module */
