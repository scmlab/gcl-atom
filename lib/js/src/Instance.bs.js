// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var View$GclAtom = require("./View.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Handler$GclAtom = require("./Handler.bs.js");
var Request$GclAtom = require("./Request.bs.js");
var Response$GclAtom = require("./Response.bs.js");
var Connection$GclAtom = require("./Connection.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(editor) {
  atom.views.getView(editor).classList.add("gcl");
  var view = View$GclAtom.make(editor);
  var connection = Connection$GclAtom.make(/* () */0);
  return /* record */Caml_chrome_debugger.record([
            "editor",
            "view",
            "connection",
            "decorations"
          ], [
            editor,
            view,
            connection,
            []
          ]);
}

function destroy(instance) {
  atom.views.getView(instance[/* editor */0]).classList.remove("gcl");
  Connection$GclAtom.disconnect(instance[/* connection */2]);
  Rebase.$$Array.forEach((function (prim) {
          prim.destroy();
          return /* () */0;
        }), instance[/* decorations */3]);
  return View$GclAtom.destroy(instance[/* editor */0]);
}

function activate(instance) {
  return Curry._1(instance[/* view */1][/* setActivation */0], true);
}

function deactivate(instance) {
  return Curry._1(instance[/* view */1][/* setActivation */0], false);
}

function dispatch(request, instance) {
  switch (request) {
    case /* Activate */0 :
        Curry._1(instance[/* view */1][/* setActivation */0], true);
        if (Connection$GclAtom.isConnected(instance[/* connection */2])) {
          return Async$GclAtom.resolve(/* () */0);
        } else {
          return Async$GclAtom.thenOk((function (param) {
                          return dispatch(/* Save */2, instance);
                        }))(Async$GclAtom.thenError((function (error) {
                              var match = Connection$GclAtom.$$Error.toString(error);
                              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                              return Async$GclAtom.resolve(/* () */0);
                            }))(Connection$GclAtom.connect(instance[/* connection */2])));
        }
    case /* Deactivate */1 :
        return Curry._1(instance[/* view */1][/* setActivation */0], false);
    case /* Save */2 :
        Rebase.$$Array.forEach((function (prim) {
                prim.destroy();
                return /* () */0;
              }), instance[/* decorations */3]);
        return Async$GclAtom.thenOk((function (result) {
                        console.log("[ received json ]", result);
                        console.log("[ received value ]", Response$GclAtom.decode(result));
                        return handle(instance, Response$GclAtom.decode(result));
                      }))(Async$GclAtom.thenOk((function (param) {
                            var filepath = instance[/* editor */0].getPath();
                            if (filepath !== undefined) {
                              return Async$GclAtom.mapError((function (error) {
                                              var match = Connection$GclAtom.$$Error.toString(error);
                                              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                                              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match[1]]));
                                              return /* () */0;
                                            }))(Connection$GclAtom.send(Request$GclAtom.encode(/* Load */Caml_chrome_debugger.simpleVariant("Load", [filepath])), instance[/* connection */2]));
                            } else {
                              Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read filepath "]));
                              Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Please save the file first"]));
                              return Async$GclAtom.reject(/* () */0);
                            }
                          }))(Async$GclAtom.mapError((function (param) {
                                return /* () */0;
                              }))(Async$GclAtom.fromPromise(instance[/* editor */0].save()))));
    
  }
}

function handle(instance, param) {
  switch (param.tag | 0) {
    case /* ParseError */0 :
        var match = Rebase.$$Array.get(param[0], 0);
        if (match !== undefined) {
          var match$1 = match;
          var pos = match$1[0];
          Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Parse Error"]));
          Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [match$1[1]]));
          var range = new Atom.Range(pos, pos);
          Handler$GclAtom.markLineError(range, instance);
          return Async$GclAtom.resolve(/* () */0);
        } else {
          Curry._1(instance[/* view */1][/* setHeader */1], /* AllGood */0);
          Curry._1(instance[/* view */1][/* setBody */2], /* Nothing */0);
          return Async$GclAtom.resolve(/* () */0);
        }
    case /* SyntaxError */1 :
        var match$2 = param[0];
        if (typeof match$2 === "number") {
          Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Postcondition Missing"]));
          Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["The last statement of the program should be an assertion"]));
          return Async$GclAtom.resolve(/* () */0);
        } else {
          switch (match$2.tag | 0) {
            case /* MissingBound */0 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Bound Missing"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Bound missing at the end of the assertion before the DO construct \" , bnd : ... }\""]));
                Handler$GclAtom.highlightError(match$2[0], instance);
                return Async$GclAtom.resolve(/* () */0);
            case /* MissingAssertion */1 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Assertion Missing"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Assertion before the DO construct is missing"]));
                Handler$GclAtom.highlightError(match$2[0], instance);
                return Async$GclAtom.resolve(/* () */0);
            case /* ExcessBound */2 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Excess Bound"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["Unnecessary bound annotation at this assertion"]));
                Handler$GclAtom.highlightError(match$2[0], instance);
                return Async$GclAtom.resolve(/* () */0);
            case /* DigHole */3 :
                return Async$GclAtom.thenOk((function (param) {
                                return dispatch(/* Save */2, instance);
                              }))(Handler$GclAtom.digHole(match$2[0], instance));
            case /* Panic */4 :
                Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic"]));
                Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, ["This should not have happened, please report this issue\n" + match$2[0]]));
                return Async$GclAtom.resolve(/* () */0);
            
          }
        }
    case /* OK */2 :
        Curry._1(instance[/* view */1][/* setHeader */1], /* Plain */Caml_chrome_debugger.variant("Plain", 0, ["Proof Obligations"]));
        Curry._1(instance[/* view */1][/* setBody */2], /* ProofObligations */Caml_chrome_debugger.variant("ProofObligations", 0, [param[0]]));
        Rebase.$$Array.forEach(Curry._2(Rebase.Fn.flip, Handler$GclAtom.markSpec, instance), param[1]);
        return Async$GclAtom.resolve(/* () */0);
    case /* UnknownResponse */3 :
        Curry._1(instance[/* view */1][/* setHeader */1], /* Error */Caml_chrome_debugger.variant("Error", 1, ["Panic: unknown response from GCL"]));
        Curry._1(instance[/* view */1][/* setBody */2], /* Plain */Caml_chrome_debugger.variant("Plain", 1, [JSON.stringify(param[0])]));
        return Async$GclAtom.resolve(/* () */0);
    
  }
}

var $$Event = 0;

exports.$$Event = $$Event;
exports.make = make;
exports.destroy = destroy;
exports.activate = activate;
exports.deactivate = deactivate;
exports.dispatch = dispatch;
exports.handle = handle;
/* atom Not a pure module */
