// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Webapi = require("bs-webapi/lib/js/src/Webapi.js");
var ReactDom = require("react-dom");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Webapi__Dom = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom.js");
var Hook$GclAtom = require("./View/Hook.bs.js");
var Async$GclAtom = require("./Util/Async.bs.js");
var Channel$GclAtom = require("./Util/Channel.bs.js");
var Connection$GclAtom = require("./Connection.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Webapi__Dom__HtmlElement = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__HtmlElement.js");

function make(param) {
  var containers = Rebase.$$Array.filter((function (elem) {
          return elem.className === "gcl-panel-container";
        }), Rebase.$$Array.flatMap((function (xs) {
              return Rebase.$$Array.filterMap(Webapi__Dom__HtmlElement.ofNode, Array.prototype.slice.call(xs.childNodes));
            }), Rebase.$$Array.map((function (prim) {
                  return atom.views.getView(prim);
                }), atom.workspace.getBottomPanels())));
  var match = Rebase.$$Array.get(containers, 0);
  if (match !== undefined) {
    return Caml_option.valFromOption(match);
  } else {
    var panelContainer = document.createElement("article");
    panelContainer.classList.add("gcl-panel-container");
    atom.workspace.addBottomPanel({
          item: panelContainer,
          priority: 0,
          visible: true
        });
    return panelContainer;
  }
}

var PanelContainer = {
  make: make
};

function make$1(param) {
  return /* record */Caml_chrome_debugger.record(["updateConnection"], [Channel$GclAtom.make(/* () */0)]);
}

var Channels = {
  make: make$1
};

function View(Props) {
  var channels = Props.channels;
  var match = Hook$GclAtom.useState(/* tuple */[
        Connection$GclAtom.make(/* () */0),
        undefined
      ]);
  var setConnectionAndError = match[1];
  var match$1 = match[0];
  var connectionError = match$1[1];
  Hook$GclAtom.useChannel((function (x) {
          return Async$GclAtom.resolve(Curry._1(setConnectionAndError, x));
        }), channels[/* updateConnection */0]);
  var connected = Connection$GclAtom.isConnected(match$1[0]);
  var status = connected ? React.createElement("span", {
          className: "icon icon-primitive-dot text-success",
          id: "connection-status",
          title: "connected"
        }) : React.createElement("span", {
          className: "icon icon-primitive-dot text-error",
          id: "connection-status",
          title: "disconnected"
        });
  var match$2 = connectionError !== undefined ? Connection$GclAtom.$$Error.toString(connectionError) : /* tuple */[
      "All good",
      ""
    ];
  return React.createElement("section", {
              className: "gcl-panel"
            }, React.createElement("h2", undefined, React.createElement("span", undefined, match$2[0]), status), React.createElement("div", undefined, React.createElement("span", undefined, match$2[1])));
}

function create(param) {
  var element = make(/* () */0);
  var channels = /* record */Caml_chrome_debugger.record(["updateConnection"], [Channel$GclAtom.make(/* () */0)]);
  var component = React.createElement(View, {
        channels: channels
      });
  ReactDom.render(component, element);
  return channels;
}

var make$2 = View;

exports.PanelContainer = PanelContainer;
exports.Channels = Channels;
exports.make = make$2;
exports.create = create;
/* react Not a pure module */
